{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Welcome to Leapp Leapp is a tool for developers to manage, secure, and gain access to any cloud. From setting up your access data to activating a session, Leapp can help manage the underlying assets to let you use your provider's CLI or SDK seamlessy. Leapp is compatible out-of-the-box with any third-party tool that uses the default cloud provider credential chain like Terraform, the Serverless Framework, Amplify, and much more. Leapp information needed to retrieve credentials are stored LOCALLY inside his workspace . Critical information such as Cloud secrets and token are stored inside the System Vault . Key Features Switch active session in a click Secure repository for your access data Multiple clouds access methods Only short-lived credentials (or none at all) Supported Services Import sessions from AWS Single Sign-On (SSO) Connect to EC2 instances without certificates through AWS System Manager (SSM) Installing You can install Leapp by downloading the pre-built binaries for your OS here . Unzip the package and double-click on the executable to install.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#welcome-to-leapp","text":"Leapp is a tool for developers to manage, secure, and gain access to any cloud. From setting up your access data to activating a session, Leapp can help manage the underlying assets to let you use your provider's CLI or SDK seamlessy. Leapp is compatible out-of-the-box with any third-party tool that uses the default cloud provider credential chain like Terraform, the Serverless Framework, Amplify, and much more. Leapp information needed to retrieve credentials are stored LOCALLY inside his workspace . Critical information such as Cloud secrets and token are stored inside the System Vault .","title":"Welcome to Leapp"},{"location":"#key-features","text":"Switch active session in a click Secure repository for your access data Multiple clouds access methods Only short-lived credentials (or none at all)","title":"Key Features"},{"location":"#supported-services","text":"Import sessions from AWS Single Sign-On (SSO) Connect to EC2 instances without certificates through AWS System Manager (SSM)","title":"Supported Services"},{"location":"#installing","text":"You can install Leapp by downloading the pre-built binaries for your OS here . Unzip the package and double-click on the executable to install.","title":"Installing"},{"location":"concepts/","text":"Concepts Leapp grants the users the generation of temporary credentials for accessing the cloud programmatically through CLI/SDK. Leapp is built with security in mind: NO credentials are saved in our system whatsoever. Nor in code neither in our configuration file. Every time a credential is generated is temporary , and no long-term ones are ever saved in plain accessible files or locations. Our main goal is to provide credentials to developers only when needed. Otherwise, those credentials are stored in a secure place (the system vault). Session A Session contains all the relevant information to let the dev connect to a cloud provider. Three standard actions should be implemented for each session: start , stop , and rotate . Start Make the temporary credentials available to the provider chain. Stop Removes the temporary credentials from the provider chain. Rotate Generate new temporary credentials, and substitute the previous ones in the provider chain. Data All Sessions shares some basic data, common to all. ID Unique identifier to the Session sessionName A fancy name for the Session to make it recognizable to the user. status Represent the State Management of a single session; when the status of a session is ACTIVE , temporary credentials are available to the user. startDateTime A UTC DateTime string representing the last time a specific Session has started; this is useful for rotation and sorting purposes. region The AWS region or Azure Location the Session is working on. type Uniquely identifies two central aspects to determine the Session: Cloud Provider and Access Method. Access Method Type identifies two central aspects to determine the Session: Cloud Provider and Access Method. The naming convention we are using is cloudProvider-accessMethod . the Cloud Provider on which you are connecting (i.e., AWS, Azure, GCP...) the Access Method used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...) The process of setting up Leapp Sessions is managed either manually , for each access method, or through integrations with third-party tools. Leapp stores all the Sessions available to the users locally, inside a configuration file called Workspace. Workspace This model represents the configuration that will be serialized and persisted into the .Leapp/Leapp-lock.json file. This file is encrypted using AES-256 encryption algorithm and the machine id as encryption key . This model contains the fields described below. sessions The list of Sessions created through Leapp. defaultRegion It corresponds to AWS's default region to which API calls are sent. The default region for AWS is us-east-1 . defaultLocation It corresponds to Azure's default region to which API calls are sent. The default region for Azure is eastus . idpUrls A list of all the Identity Provider URLs used from AWS IAM Roles Federated Sessions. profiles The list of profiles - characterized by an id and a name - that can be associated with Sessions. Integrations Session integration is referred to as a process of bringing data coming from different sources to Leapp. Tools like AWS Single Sign-On, OneLogin Multi-Account AWS Access, Okta AWS Multi-Account, and Hashicorp Vault, grants the developers a list of all the available Cloud environment they can access. An integration can map an available Cloud environment they can access, to a Leapp Session and automatically add it in-app. Each integration is linked to a specific Access Method to generate credentials for a specific Cloud Provider from the information inside a Session.","title":"Concepts"},{"location":"concepts/#concepts","text":"Leapp grants the users the generation of temporary credentials for accessing the cloud programmatically through CLI/SDK. Leapp is built with security in mind: NO credentials are saved in our system whatsoever. Nor in code neither in our configuration file. Every time a credential is generated is temporary , and no long-term ones are ever saved in plain accessible files or locations. Our main goal is to provide credentials to developers only when needed. Otherwise, those credentials are stored in a secure place (the system vault).","title":"Concepts"},{"location":"concepts/#session","text":"A Session contains all the relevant information to let the dev connect to a cloud provider. Three standard actions should be implemented for each session: start , stop , and rotate .","title":"Session"},{"location":"concepts/#start","text":"Make the temporary credentials available to the provider chain.","title":"Start"},{"location":"concepts/#stop","text":"Removes the temporary credentials from the provider chain.","title":"Stop"},{"location":"concepts/#rotate","text":"Generate new temporary credentials, and substitute the previous ones in the provider chain.","title":"Rotate"},{"location":"concepts/#data","text":"All Sessions shares some basic data, common to all.","title":"Data"},{"location":"concepts/#id","text":"Unique identifier to the Session","title":"ID"},{"location":"concepts/#sessionname","text":"A fancy name for the Session to make it recognizable to the user.","title":"sessionName"},{"location":"concepts/#status","text":"Represent the State Management of a single session; when the status of a session is ACTIVE , temporary credentials are available to the user.","title":"status"},{"location":"concepts/#startdatetime","text":"A UTC DateTime string representing the last time a specific Session has started; this is useful for rotation and sorting purposes.","title":"startDateTime"},{"location":"concepts/#region","text":"The AWS region or Azure Location the Session is working on.","title":"region"},{"location":"concepts/#type","text":"Uniquely identifies two central aspects to determine the Session: Cloud Provider and Access Method.","title":"type"},{"location":"concepts/#access-method","text":"Type identifies two central aspects to determine the Session: Cloud Provider and Access Method. The naming convention we are using is cloudProvider-accessMethod . the Cloud Provider on which you are connecting (i.e., AWS, Azure, GCP...) the Access Method used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...) The process of setting up Leapp Sessions is managed either manually , for each access method, or through integrations with third-party tools. Leapp stores all the Sessions available to the users locally, inside a configuration file called Workspace.","title":"Access Method"},{"location":"concepts/#workspace","text":"This model represents the configuration that will be serialized and persisted into the .Leapp/Leapp-lock.json file. This file is encrypted using AES-256 encryption algorithm and the machine id as encryption key . This model contains the fields described below. sessions The list of Sessions created through Leapp. defaultRegion It corresponds to AWS's default region to which API calls are sent. The default region for AWS is us-east-1 . defaultLocation It corresponds to Azure's default region to which API calls are sent. The default region for Azure is eastus . idpUrls A list of all the Identity Provider URLs used from AWS IAM Roles Federated Sessions. profiles The list of profiles - characterized by an id and a name - that can be associated with Sessions.","title":"Workspace"},{"location":"concepts/#integrations","text":"Session integration is referred to as a process of bringing data coming from different sources to Leapp. Tools like AWS Single Sign-On, OneLogin Multi-Account AWS Access, Okta AWS Multi-Account, and Hashicorp Vault, grants the developers a list of all the available Cloud environment they can access. An integration can map an available Cloud environment they can access, to a Leapp Session and automatically add it in-app. Each integration is linked to a specific Access Method to generate credentials for a specific Cloud Provider from the information inside a Session.","title":"Integrations"},{"location":"community/get_involved/","text":"Get involved Website: https://www.leapp.cloud/ Roadmap: Roadmap Wiki: Wiki Chat with us: Slack","title":"Get Involved"},{"location":"community/get_involved/#get-involved","text":"Website: https://www.leapp.cloud/ Roadmap: Roadmap Wiki: Wiki Chat with us: Slack","title":"Get involved"},{"location":"community/guides/","text":"Guides and resources Supported Providers Cloud Providers AWS - AZURE - GCP - Alibaba Cloud - Identity Providers G Suite to AWS - Okta to AWS - OneLogin to AWS - G Suite to Azure - AZURE AD to Azure - AZURE AD to AWS - AWS Single Sign-On - Use Cases Our use cases are hereby presented to give you a hint on how Leapp can be of help to depend on the type of setup you have in your company and what kind of credentials you need to get.","title":"Guides and Resources"},{"location":"community/guides/#guides-and-resources","text":"","title":"Guides and resources"},{"location":"community/guides/#supported-providers","text":"","title":"Supported Providers"},{"location":"community/guides/#cloud-providers","text":"AWS - AZURE - GCP - Alibaba Cloud -","title":"Cloud Providers"},{"location":"community/guides/#identity-providers","text":"G Suite to AWS - Okta to AWS - OneLogin to AWS - G Suite to Azure - AZURE AD to Azure - AZURE AD to AWS - AWS Single Sign-On -","title":"Identity Providers"},{"location":"community/guides/#use-cases","text":"Our use cases are hereby presented to give you a hint on how Leapp can be of help to depend on the type of setup you have in your company and what kind of credentials you need to get.","title":"Use Cases"},{"location":"contributing/structure/aws_named_profiles/","text":"Named Profiles are a way AWS uses to maintain more than one set of credentials active for you to use with AWS-CLI, SDK, or other third-party tools. Named profiles are stored in ~/.aws/credentials file in the ini file format . Named Profiles have a default one which is the one you get from aws configure command. Leapp can, from release 0.4.7 , manage more than one profile, to allow users to have multiple credentials set at the same time. Named Profiles are selectable directly when creating an AWS session ( Federated , Truster , Plain ), by using the selector provided in the form. It is also possible to create a new named profile directly from the selector by typing a new name and by pressing ENTER key . The new name is directly added to the named profile list and it will be possible to use it for other sessions too. AWS SSO sessions will have default as named profile when obtained through Login or Sync, to change the named profile associated to a session you have to use the \"Change Profile\" option in the session list. Named Profile List Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile. Session Options A named profile can also be changed directly from an AWS session element in the main list . There you can add or select a new named profile the same way you would from the add session form . Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"AWS Named Profiles"},{"location":"contributing/structure/aws_named_profiles/#named-profile-list","text":"Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile.","title":"Named Profile List"},{"location":"contributing/structure/aws_named_profiles/#session-options","text":"A named profile can also be changed directly from an AWS session element in the main list . There you can add or select a new named profile the same way you would from the add session form . Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"Session Options"},{"location":"contributing/structure/aws_sso/","text":"Why Using AWS SSO with Leapp When using AWS SSO directly with tools like AWS CLI V2 a specific profile is defined for the user when using aws configure . Because of that you lose compatibility with lots of tools and libraries that uses the standard profile. Leapp believes that tools and software must always use simple, flat, short-lived credentials, avoiding to leave any sensitive information in the profile. That is why Leapp takes care for you of the authentication process, no matter what strategy do you plan to use. Because of this, Leapp allows AWS SSO to be compatible with AWS Cli V2 and many others libraries out there, because at the end of its process you'll have plain temporary credentials to use. How Leapp integrates with AWS SSO under the hood The Auth flow in AWS SSO is made up with OIDC and is divided in three different steps: RegisterClient StartDeviceAuthorization CreateToken note: CREDENTIALS ARE NOT NEEDED FOR THOSE THREE CALLS The first thing we have to do is to register a local client. The AWS SSO OIDC service currently implements only the portions of the OAuth 2.0 Device Authorization Grant standard ( https://tools.ietf.org/html/rfc8628 ) that are necessary to enable SSO authentication with the AWS CLI. Support for other OIDC flows frequently needed for native applications, such as Authorization Code Flow (+ PKCE), is planned in future releases. RegisterClient As soon as the aws sso button is clicked, the RegisterClient Api will be invoked. aws sso-oidc register-client --client-name leapp --client-type public notes: public is the only client type available at the moment. it will generate a response like the one below: { \"clientId\": \"ClhqC9rDzjY43Nh0nYEL-2V1LXdlc3QtMQ\", \"clientSecret\": \"eyJraWQiOiJrZXktMTU2Njk2ODAxMyIsImFsZyI6IkhTMzg0In0.eyJzZXJpYWxpemVkIjoie1wiZXhwaXJlZFwiOmZhbHNlLFwiY2xpZW50SWRcIjp7XCJ2YWx1ZVwiOlwiQ2xocUM5ckR6alk0M05oMG5ZRUwtMlYxTFhkbGMzUXRNUVwifSxcInRlbmFudElkXCI6bnVsbCxcImNsaWVudE5hbWVcIjpcImxlYXBwLXRlc3RcIixcImNsaWVudFR5cGVcIjpcIlBVQkxJQ1wiLFwidGVtcGxhdGVBcm5cIjpudWxsLFwidGVtcGxhdGVDb250ZXh0XCI6bnVsbCxcImV4cGlyYXRpb25UaW1lc3RhbXBcIjoxNjExNjc0Njg2Ljg0MTAwMDAwMCxcImNyZWF0ZWRUaW1lc3RhbXBcIjoxNjAzODk4Njg2Ljg0MTAwMDAwMCxcInVwZGF0ZWRUaW1lc3RhbXBcIjoxNjAzODk4Njg2Ljg0MTAwMDAwMCxcImNyZWF0ZWRCeVwiOm51bGwsXCJ1cGRhdGVkQnlcIjpudWxsLFwic3RhdHVzXCI6bnVsbCxcImluaXRpYXRlTG9naW5VcmlcIjpudWxsLFwiZW50aXRsZWRSZXNvdXJjZUlkXCI6bnVsbCxcImVudGl0bGVkUmVzb3VyY2VDb250YWluZXJJZFwiOm51bGwsXCJleHRlcm5hbElkXCI6bnVsbH0ifQ.s5fnQhh7J70RGxcUsSUvI08ptEr8dqIWPQRVAq0DFGrdsqea6d411ExkKhbGJRlK\", \"clientIdIssuedAt\": 1603898686, \"clientSecretExpiresAt\": 1611674686 } By decoding the Client secret you will see: { \"expired\": false, \"clientId\": { \"value\": \"R-j5yN-4-TPNs...tMQ\" }, \"clientName\": \"my-client\", \"clientType\": \"PUBLIC\", \"templateArn\": null, \"templateContext\": null, \"expirationTimestamp\": 1594932567.612, \"createdTimestamp\": 1587156567.612, \"updatedTimestamp\": 1587156567.612, \"createdBy\": null, \"updatedBy\": null } We have to locally save those info and pass them into the next call. StartDeviceAuthorization In order to make this call the user of Leapp need to have registered into AWS SSO and provide a valid start-url, that is the portal url Having a valid OIDC client registration we can now initiate the device authorization flow using the StartDeviceAuthorization API action. aws sso-oidc start-device-authorization --client-id mVZBEoa-gUBj8nugHZUIsWV1LXdlc3QtMQ --client-secret eyJraWQiOiJrZXktMTU2Njk2ODAxMyIsImFsZyI6IkhTMzg0In0.eyJzZXJpYWxpemVkIjoie1wiZXhwaXJlZFwiOmZhbHNlLFwiY2xpZW50SWRcIjp7XCJ2YWx1ZVwiOlwibVZaQkVvYS1nVUJqOG51Z0haVUlzV1YxTFhkbGMzUXRNUVwifSxcInRlbmFudElkXCI6bnVsbCxcImNsaWVudE5hbWVcIjpcImxlYXBwXCIsXCJjbGllbnRUeXBlXCI6XCJQVUJMSUNcIixcInRlbXBsYXRlQXJuXCI6bnVsbCxcInRlbXBsYXRlQ29udGV4dFwiOm51bGwsXCJleHBpcmF0aW9uVGltZXN0YW1wXCI6MTYxMTU2ODM0MS45MDkwMDAwMDAsXCJjcmVhdGVkVGltZXN0YW1wXCI6MTYwMzc5MjM0MS45MDkwMDAwMDAsXCJ1cGRhdGVkVGltZXN0YW1wXCI6MTYwMzc5MjM0MS45MDkwMDAwMDAsXCJjcmVhdGVkQnlcIjpudWxsLFwidXBkYXRlZEJ5XCI6bnVsbCxcInN0YXR1c1wiOm51bGwsXCJpbml0aWF0ZUxvZ2luVXJpXCI6bnVsbCxcImVudGl0bGVkUmVzb3VyY2VJZFwiOm51bGwsXCJlbnRpdGxlZFJlc291cmNlQ29udGFpbmVySWRcIjpudWxsLFwiZXh0ZXJuYWxJZFwiOm51bGx9In0.nyRt2ELVoiBh95GiZ_Igzzsn4DkzwfiU446c0lvuS9yqJe5Fk2Ra_tV-htKetQH8 --start-url [https://u](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/sso-oidc/start-device-authorization.html)rltoSSOendpoint That will produce a response like this: { \"deviceCode\": \"8Acq...DUg\", \"expiresIn\": 600, \"interval\": 1, \"userCode\": \"RPXP-JSQA\", \"verificationUri\": \"https://device.sso.eu-central-1.amazonaws.com/\", \"verificationUriComplete\": \"https://device.sso.eu-central-1.amazonaws.com/?user_code=RPXP-JSQA\" } Where: deviceCode : The short-lived code that is used by the device when polling for a session token. expiresIn : Indicates the number of seconds in which the verification code will become invalid. interval : Indicates the number of seconds the client must wait between attempts when polling for a session. userCode : A one-time user verification code. This is needed to authorize an in-use device. verificationUri : The URI of the verification page that takes the userCode to authorize the device. verificationUriComplete : An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code. In order to verify this device, Leapp will prompt you to the LOGIN PAGE and the verification code page, by opening a web browser with the verificationUriComplete After the verification of the device we can now call the CreateToken API CreateToken Having the userCode and deviceCode values we can now us the CreateToken API action to obtain a device access token. However, before we can request any tokens we need to open the verificationUriComplete URL in a web browser, complete authentication and provide authorization. At this point the end-user has to provide personal credentials in order to authenticate himself, for example by entering his username, password and maybe also has to provide multi factory authentication (MFA) credentials. curl -X POST https://oidc.eu-central-1.amazonaws.com/token -d '{\"clientId\": \"R-j5yN-4-TPNs...tMQ\", \"clientSecret\": \"eyJr...x74\", \"deviceCode\": \"8Acq...DUg\", \"grantType\": \"urn:ietf:params:oauth:grant-type:device_code\"}' If everything worked out as expected, the token endpoint will return a valid accessToken, which we later can use with the AWS SSO Portal API to obtain temporary AWS credentials using the GetRoleCredentials action. The returned tokens are valid for 8 hours. This API call is region sensible, so we have to extract the region from the verificationUriComplete url with a RegEx! With this token we can now call the AWS SSO Portal API to autogenerate sessions in Leapp. AWS SSO Portal API In order to fill the session available with AWS SSO we have to use those APIs The following actions are supported: GetRoleCredentials ListAccountRoles ListAccounts Logout and in order to complete this action we need scan for account and roles inside them. ListAccounts Lists all AWS accounts assigned to the user. These AWS accounts are assigned by the administrator of the account. GET /assignment/accounts?max_result=maxResults&next_token=nextToken HTTP/1.1 x-amz-sso_bearer_token: accessToken accessToken : The token issued by the CreateToken API call. Required: Yes maxResults : This is the number of items clients can request per page. Valid Range: Minimum value of 1. Maximum value of 100. nextToken : When requesting subsequent pages, this is the page token from the previous response output. Required: NO RESPONSE { \"accountList\": [ { \"accountId\": \"string\", \"accountName\": \"string\", \"emailAddress\": \"string\" } ], \"nextToken\": \"string\" } The following data is returned in JSON format by the service. accountList : A paginated response with the list of account information and the next token if more results are available. accountId: The identifier of the AWS account that is assigned to the user. accountName The display name of the AWS account that is assigned to the user. emailAddress The email address of the AWS account that is assigned to the user. Length For each account retrieved by this API we need to check all the possible roles inside it. ListAccountRoles ListAccountRoles aws sso list-account-roles --access-token eyJlbmMiOiJBMjU2R0NNIiwidGFnIjoiT25ZVUUxVFdOTkJPTHBlXyIsImFsZyI6IkEyNTZHQ01LVyIsIml2IjoiTlN6OGZhX3R5OUlTQ2pDSCJ9.AYABeE2XhZfXOo0AQH4b8xBx2IcAHwABABBEYXRhUGxhbmVTZXNzaW9uAAlQZXJlZ3JpbmUAAQAHYXdzLWttcwBLYXJuOmF3czprbXM6ZXUtd2VzdC0xOjU2ODkwNzQ4NjgzOTprZXkvZjgxOTE5ODYtODUxMi00MjUxLWE2OGItZjA1ZDc4NzNjY2MwALgBAgEAeJu9skq4zE2ey9fc15hIacoXwiFFMAppCV0W0rSVkM8-AfyfQxekoSqPhi7I-4NV30sAAAB-MHwGCSqGSIb3DQEHBqBvMG0CAQAwaAYJKoZIhvcNAQcBMB4GCWCGSAFlAwQBLjARBAxmhCL0DkKsDKDXCOACARCAO3Eve3w-RA7Qhr2OXf2rIzq27GqRNnym4mKIr1GRApaqQg045HyPCu8sOPVAJ5hNkuozdXFEyLWczHixAgAAAAAMAAAQAAAAAAAAAAAAAAAAAF7LbxztBp6QTtJLUfx0lz______AAAAAQAAAAAAAAAAAAAAAQAAACCLZim2-nRmKQ1xBgn6dyEcIYkErQ3JrZD3xH2QVJWUzbKlF9iq4MY_GHL9IqjFzVc.SEOxHOT20ShnIeWq.i5iBKVf-UnQQxODhm9wr_HNfZVsr0vfp7afk0DXWMyom41khUS5eH8-i8K6kqZSxhxsyX6Pf502c-h0iIGYjZZEZ8jvoYnYTr900w8mjNAP1G1r-6gpqLSBw8wgEe194VfPmbMP6lL534fAwQeqQBBvUjDgCGsUgn3SniGXeTR-x7khc01Mvf6ocHAvkjAsdz3s0zsXjZDUsCId8XlWZaeapsJ9_JGOx_UmzhGeMY96JtwWcRKjGLOVaT2E8rkU32RZwgwWQGkTpLI75_IWlsfgj69nDpUYc65AsJHk0vywa7xbS9F_oYrgAzqUPBPbc8WTxOSejljCpefOjSSBRkzuTFw9YKhDOs4G_gS6pg-LFFN-WVIYuLAELRalZspk3WeTyUsJK_aFxUnY3sEUzEqF8TWMIK8AXKW0m8fBI8-zuzJvmVrYdcnf6u2oyd-Q_m3sxm2va1Ec_cKYPWUtLOp8.ZCp-zED2Sv2nZEpteo-dHw --account-id 198863347786 Response: { \"roleList\": [ { \"roleName\": \"ViewOnlyAccess\", \"accountId\": \"198863347786\" } ] } After that for each pair of Account and role found we will add an AWS session that is available to get the correct credentials. GetRoleCredentials Having a valid access token, we can use the AWS SSO Portal API to obtain temporary AWS credentials using the GetRoleCredentials action. curl 'https://portal.sso.eu-central-1.amazonaws.com/federation/credentials?account_id=999999999999&role_name=MyIamRoleName' -H 'x-amz-sso_bearer_token: eyJl...Blw' Which will then provide us with temporary AWS session credentials, which by default are valid for 12 hours. { \"roleCredentials\": { \"accessKeyId\": \"ASIA...Z3XM\", \"secretAccessKey\": \"+t6UnVLWia...hFOzGL\", \"sessionToken\": \"IQoJb3JpZ2lu...dK6\", \"expiration\": 1587361828000 } } We've tried several additional query parameters ( session_duration , duration_seconds , \u2026) to figure out whether one can choose a shorter session duration, but it looks like 12 hours is all you can get. While AWS STS API \u2019s actions like AssumeRole or AssumeRoleWithWebIdentity allow callers to specify custom session duration, GetRoleCredentials does not yet support that. FAQ Q: Can I use Leapp AWS SSO with AWS Cli V2? A: Yes you can, Leapp is compatible with both AWS Cli V1 and V2. Q: I put the portal url and the region in the AWS SSO configuration but the login keeps saying Invalid Grants? A: Verify that are using the correct region which must be equal to the one you've registered your AWS SSO portal. Q: Can I use an AWS SSO session as a federated one for making a truster account? A: Yes you can, but there is currently a limit: after 8h the access token is refreshed, and the AWS SSO session is reloaded. So the association is lost and must be reverted by hand. We already opened an issue, upvote it to increase the priority. Q: How much the access token lasts? A: The access token for AWS SSO lasts for 8h, after that period the sessions are synchronized again automatically. Q: My administrator has changed some accounts and roles but I can't see them? A: Synchronizing is done when access token expires, you can force a manual re-synch from the AWS SSO page. Q: Can I use Leapp AWS SSO session with AWS SSM? A: Yes you can, just be sure to have the correct permissions AWS-side and you're good to go. Q: Can I use Leapp AWS SSO sessions to issue AWS commands with my ? A: Yes you can, Leapp generates under the hood plain temporary credentials in your default profile. If for any reason you find some incompatibilities, please fill a new issue Q: I can't find my portal URL, when I try to access AWS SSO service it points me to presentation page but there is no admin console? A: To have access to AWS SSO console you must have privileges for that, please check your email or contact your administrator to obtain a portal URL. Q: Why there are no options to edit or delete AWS SSO accounts? A: AWS SSO management is done via AWS console by your administrator, you only have read access to the sessions, no need to edit or remove them. Q: I only see the name of the account and the role, can I recover other information for my work? A: Yes you can, you can copy the role arn and the account number from the contextual menu. Q: Can I use MFA with Leapp and AWS SSO? A: Yes, if your administrator has configured MFA for your AWS SSO account you'll be prompted for the code during authentication process. Q: I've installed Leapp, before I was using AWS SSO with CLI v2. It says my credentials are expired, what can I do? A: Clear cli/ folder, clear sso/ inside ~/.aws . Also, be sure to clean ~/.aws/config because it will probably contains data from your previous setup.","title":"AWS SSO"},{"location":"contributing/structure/aws_sso/#why-using-aws-sso-with-leapp","text":"When using AWS SSO directly with tools like AWS CLI V2 a specific profile is defined for the user when using aws configure . Because of that you lose compatibility with lots of tools and libraries that uses the standard profile. Leapp believes that tools and software must always use simple, flat, short-lived credentials, avoiding to leave any sensitive information in the profile. That is why Leapp takes care for you of the authentication process, no matter what strategy do you plan to use. Because of this, Leapp allows AWS SSO to be compatible with AWS Cli V2 and many others libraries out there, because at the end of its process you'll have plain temporary credentials to use.","title":"Why Using AWS SSO with Leapp"},{"location":"contributing/structure/aws_sso/#how-leapp-integrates-with-aws-sso-under-the-hood","text":"The Auth flow in AWS SSO is made up with OIDC and is divided in three different steps: RegisterClient StartDeviceAuthorization CreateToken note: CREDENTIALS ARE NOT NEEDED FOR THOSE THREE CALLS The first thing we have to do is to register a local client. The AWS SSO OIDC service currently implements only the portions of the OAuth 2.0 Device Authorization Grant standard ( https://tools.ietf.org/html/rfc8628 ) that are necessary to enable SSO authentication with the AWS CLI. Support for other OIDC flows frequently needed for native applications, such as Authorization Code Flow (+ PKCE), is planned in future releases.","title":"How Leapp integrates with AWS SSO under the hood"},{"location":"contributing/structure/aws_sso/#registerclient","text":"As soon as the aws sso button is clicked, the RegisterClient Api will be invoked. aws sso-oidc register-client --client-name leapp --client-type public notes: public is the only client type available at the moment. it will generate a response like the one below: { \"clientId\": \"ClhqC9rDzjY43Nh0nYEL-2V1LXdlc3QtMQ\", \"clientSecret\": \"eyJraWQiOiJrZXktMTU2Njk2ODAxMyIsImFsZyI6IkhTMzg0In0.eyJzZXJpYWxpemVkIjoie1wiZXhwaXJlZFwiOmZhbHNlLFwiY2xpZW50SWRcIjp7XCJ2YWx1ZVwiOlwiQ2xocUM5ckR6alk0M05oMG5ZRUwtMlYxTFhkbGMzUXRNUVwifSxcInRlbmFudElkXCI6bnVsbCxcImNsaWVudE5hbWVcIjpcImxlYXBwLXRlc3RcIixcImNsaWVudFR5cGVcIjpcIlBVQkxJQ1wiLFwidGVtcGxhdGVBcm5cIjpudWxsLFwidGVtcGxhdGVDb250ZXh0XCI6bnVsbCxcImV4cGlyYXRpb25UaW1lc3RhbXBcIjoxNjExNjc0Njg2Ljg0MTAwMDAwMCxcImNyZWF0ZWRUaW1lc3RhbXBcIjoxNjAzODk4Njg2Ljg0MTAwMDAwMCxcInVwZGF0ZWRUaW1lc3RhbXBcIjoxNjAzODk4Njg2Ljg0MTAwMDAwMCxcImNyZWF0ZWRCeVwiOm51bGwsXCJ1cGRhdGVkQnlcIjpudWxsLFwic3RhdHVzXCI6bnVsbCxcImluaXRpYXRlTG9naW5VcmlcIjpudWxsLFwiZW50aXRsZWRSZXNvdXJjZUlkXCI6bnVsbCxcImVudGl0bGVkUmVzb3VyY2VDb250YWluZXJJZFwiOm51bGwsXCJleHRlcm5hbElkXCI6bnVsbH0ifQ.s5fnQhh7J70RGxcUsSUvI08ptEr8dqIWPQRVAq0DFGrdsqea6d411ExkKhbGJRlK\", \"clientIdIssuedAt\": 1603898686, \"clientSecretExpiresAt\": 1611674686 } By decoding the Client secret you will see: { \"expired\": false, \"clientId\": { \"value\": \"R-j5yN-4-TPNs...tMQ\" }, \"clientName\": \"my-client\", \"clientType\": \"PUBLIC\", \"templateArn\": null, \"templateContext\": null, \"expirationTimestamp\": 1594932567.612, \"createdTimestamp\": 1587156567.612, \"updatedTimestamp\": 1587156567.612, \"createdBy\": null, \"updatedBy\": null } We have to locally save those info and pass them into the next call.","title":"RegisterClient"},{"location":"contributing/structure/aws_sso/#startdeviceauthorization","text":"In order to make this call the user of Leapp need to have registered into AWS SSO and provide a valid start-url, that is the portal url Having a valid OIDC client registration we can now initiate the device authorization flow using the StartDeviceAuthorization API action. aws sso-oidc start-device-authorization --client-id mVZBEoa-gUBj8nugHZUIsWV1LXdlc3QtMQ --client-secret eyJraWQiOiJrZXktMTU2Njk2ODAxMyIsImFsZyI6IkhTMzg0In0.eyJzZXJpYWxpemVkIjoie1wiZXhwaXJlZFwiOmZhbHNlLFwiY2xpZW50SWRcIjp7XCJ2YWx1ZVwiOlwibVZaQkVvYS1nVUJqOG51Z0haVUlzV1YxTFhkbGMzUXRNUVwifSxcInRlbmFudElkXCI6bnVsbCxcImNsaWVudE5hbWVcIjpcImxlYXBwXCIsXCJjbGllbnRUeXBlXCI6XCJQVUJMSUNcIixcInRlbXBsYXRlQXJuXCI6bnVsbCxcInRlbXBsYXRlQ29udGV4dFwiOm51bGwsXCJleHBpcmF0aW9uVGltZXN0YW1wXCI6MTYxMTU2ODM0MS45MDkwMDAwMDAsXCJjcmVhdGVkVGltZXN0YW1wXCI6MTYwMzc5MjM0MS45MDkwMDAwMDAsXCJ1cGRhdGVkVGltZXN0YW1wXCI6MTYwMzc5MjM0MS45MDkwMDAwMDAsXCJjcmVhdGVkQnlcIjpudWxsLFwidXBkYXRlZEJ5XCI6bnVsbCxcInN0YXR1c1wiOm51bGwsXCJpbml0aWF0ZUxvZ2luVXJpXCI6bnVsbCxcImVudGl0bGVkUmVzb3VyY2VJZFwiOm51bGwsXCJlbnRpdGxlZFJlc291cmNlQ29udGFpbmVySWRcIjpudWxsLFwiZXh0ZXJuYWxJZFwiOm51bGx9In0.nyRt2ELVoiBh95GiZ_Igzzsn4DkzwfiU446c0lvuS9yqJe5Fk2Ra_tV-htKetQH8 --start-url [https://u](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/sso-oidc/start-device-authorization.html)rltoSSOendpoint That will produce a response like this: { \"deviceCode\": \"8Acq...DUg\", \"expiresIn\": 600, \"interval\": 1, \"userCode\": \"RPXP-JSQA\", \"verificationUri\": \"https://device.sso.eu-central-1.amazonaws.com/\", \"verificationUriComplete\": \"https://device.sso.eu-central-1.amazonaws.com/?user_code=RPXP-JSQA\" } Where: deviceCode : The short-lived code that is used by the device when polling for a session token. expiresIn : Indicates the number of seconds in which the verification code will become invalid. interval : Indicates the number of seconds the client must wait between attempts when polling for a session. userCode : A one-time user verification code. This is needed to authorize an in-use device. verificationUri : The URI of the verification page that takes the userCode to authorize the device. verificationUriComplete : An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code. In order to verify this device, Leapp will prompt you to the LOGIN PAGE and the verification code page, by opening a web browser with the verificationUriComplete After the verification of the device we can now call the CreateToken API","title":"StartDeviceAuthorization"},{"location":"contributing/structure/aws_sso/#createtoken","text":"Having the userCode and deviceCode values we can now us the CreateToken API action to obtain a device access token. However, before we can request any tokens we need to open the verificationUriComplete URL in a web browser, complete authentication and provide authorization. At this point the end-user has to provide personal credentials in order to authenticate himself, for example by entering his username, password and maybe also has to provide multi factory authentication (MFA) credentials. curl -X POST https://oidc.eu-central-1.amazonaws.com/token -d '{\"clientId\": \"R-j5yN-4-TPNs...tMQ\", \"clientSecret\": \"eyJr...x74\", \"deviceCode\": \"8Acq...DUg\", \"grantType\": \"urn:ietf:params:oauth:grant-type:device_code\"}' If everything worked out as expected, the token endpoint will return a valid accessToken, which we later can use with the AWS SSO Portal API to obtain temporary AWS credentials using the GetRoleCredentials action. The returned tokens are valid for 8 hours. This API call is region sensible, so we have to extract the region from the verificationUriComplete url with a RegEx! With this token we can now call the AWS SSO Portal API to autogenerate sessions in Leapp.","title":"CreateToken"},{"location":"contributing/structure/aws_sso/#aws-sso-portal-api","text":"In order to fill the session available with AWS SSO we have to use those APIs The following actions are supported: GetRoleCredentials ListAccountRoles ListAccounts Logout and in order to complete this action we need scan for account and roles inside them.","title":"AWS SSO Portal API"},{"location":"contributing/structure/aws_sso/#listaccounts","text":"Lists all AWS accounts assigned to the user. These AWS accounts are assigned by the administrator of the account. GET /assignment/accounts?max_result=maxResults&next_token=nextToken HTTP/1.1 x-amz-sso_bearer_token: accessToken accessToken : The token issued by the CreateToken API call. Required: Yes maxResults : This is the number of items clients can request per page. Valid Range: Minimum value of 1. Maximum value of 100. nextToken : When requesting subsequent pages, this is the page token from the previous response output. Required: NO RESPONSE { \"accountList\": [ { \"accountId\": \"string\", \"accountName\": \"string\", \"emailAddress\": \"string\" } ], \"nextToken\": \"string\" } The following data is returned in JSON format by the service. accountList : A paginated response with the list of account information and the next token if more results are available. accountId: The identifier of the AWS account that is assigned to the user. accountName The display name of the AWS account that is assigned to the user. emailAddress The email address of the AWS account that is assigned to the user. Length For each account retrieved by this API we need to check all the possible roles inside it.","title":"ListAccounts"},{"location":"contributing/structure/aws_sso/#listaccountroles","text":"ListAccountRoles aws sso list-account-roles --access-token eyJlbmMiOiJBMjU2R0NNIiwidGFnIjoiT25ZVUUxVFdOTkJPTHBlXyIsImFsZyI6IkEyNTZHQ01LVyIsIml2IjoiTlN6OGZhX3R5OUlTQ2pDSCJ9.AYABeE2XhZfXOo0AQH4b8xBx2IcAHwABABBEYXRhUGxhbmVTZXNzaW9uAAlQZXJlZ3JpbmUAAQAHYXdzLWttcwBLYXJuOmF3czprbXM6ZXUtd2VzdC0xOjU2ODkwNzQ4NjgzOTprZXkvZjgxOTE5ODYtODUxMi00MjUxLWE2OGItZjA1ZDc4NzNjY2MwALgBAgEAeJu9skq4zE2ey9fc15hIacoXwiFFMAppCV0W0rSVkM8-AfyfQxekoSqPhi7I-4NV30sAAAB-MHwGCSqGSIb3DQEHBqBvMG0CAQAwaAYJKoZIhvcNAQcBMB4GCWCGSAFlAwQBLjARBAxmhCL0DkKsDKDXCOACARCAO3Eve3w-RA7Qhr2OXf2rIzq27GqRNnym4mKIr1GRApaqQg045HyPCu8sOPVAJ5hNkuozdXFEyLWczHixAgAAAAAMAAAQAAAAAAAAAAAAAAAAAF7LbxztBp6QTtJLUfx0lz______AAAAAQAAAAAAAAAAAAAAAQAAACCLZim2-nRmKQ1xBgn6dyEcIYkErQ3JrZD3xH2QVJWUzbKlF9iq4MY_GHL9IqjFzVc.SEOxHOT20ShnIeWq.i5iBKVf-UnQQxODhm9wr_HNfZVsr0vfp7afk0DXWMyom41khUS5eH8-i8K6kqZSxhxsyX6Pf502c-h0iIGYjZZEZ8jvoYnYTr900w8mjNAP1G1r-6gpqLSBw8wgEe194VfPmbMP6lL534fAwQeqQBBvUjDgCGsUgn3SniGXeTR-x7khc01Mvf6ocHAvkjAsdz3s0zsXjZDUsCId8XlWZaeapsJ9_JGOx_UmzhGeMY96JtwWcRKjGLOVaT2E8rkU32RZwgwWQGkTpLI75_IWlsfgj69nDpUYc65AsJHk0vywa7xbS9F_oYrgAzqUPBPbc8WTxOSejljCpefOjSSBRkzuTFw9YKhDOs4G_gS6pg-LFFN-WVIYuLAELRalZspk3WeTyUsJK_aFxUnY3sEUzEqF8TWMIK8AXKW0m8fBI8-zuzJvmVrYdcnf6u2oyd-Q_m3sxm2va1Ec_cKYPWUtLOp8.ZCp-zED2Sv2nZEpteo-dHw --account-id 198863347786 Response: { \"roleList\": [ { \"roleName\": \"ViewOnlyAccess\", \"accountId\": \"198863347786\" } ] } After that for each pair of Account and role found we will add an AWS session that is available to get the correct credentials.","title":"ListAccountRoles"},{"location":"contributing/structure/aws_sso/#getrolecredentials","text":"Having a valid access token, we can use the AWS SSO Portal API to obtain temporary AWS credentials using the GetRoleCredentials action. curl 'https://portal.sso.eu-central-1.amazonaws.com/federation/credentials?account_id=999999999999&role_name=MyIamRoleName' -H 'x-amz-sso_bearer_token: eyJl...Blw' Which will then provide us with temporary AWS session credentials, which by default are valid for 12 hours. { \"roleCredentials\": { \"accessKeyId\": \"ASIA...Z3XM\", \"secretAccessKey\": \"+t6UnVLWia...hFOzGL\", \"sessionToken\": \"IQoJb3JpZ2lu...dK6\", \"expiration\": 1587361828000 } } We've tried several additional query parameters ( session_duration , duration_seconds , \u2026) to figure out whether one can choose a shorter session duration, but it looks like 12 hours is all you can get. While AWS STS API \u2019s actions like AssumeRole or AssumeRoleWithWebIdentity allow callers to specify custom session duration, GetRoleCredentials does not yet support that.","title":"GetRoleCredentials"},{"location":"contributing/structure/aws_sso/#faq","text":"Q: Can I use Leapp AWS SSO with AWS Cli V2? A: Yes you can, Leapp is compatible with both AWS Cli V1 and V2. Q: I put the portal url and the region in the AWS SSO configuration but the login keeps saying Invalid Grants? A: Verify that are using the correct region which must be equal to the one you've registered your AWS SSO portal. Q: Can I use an AWS SSO session as a federated one for making a truster account? A: Yes you can, but there is currently a limit: after 8h the access token is refreshed, and the AWS SSO session is reloaded. So the association is lost and must be reverted by hand. We already opened an issue, upvote it to increase the priority. Q: How much the access token lasts? A: The access token for AWS SSO lasts for 8h, after that period the sessions are synchronized again automatically. Q: My administrator has changed some accounts and roles but I can't see them? A: Synchronizing is done when access token expires, you can force a manual re-synch from the AWS SSO page. Q: Can I use Leapp AWS SSO session with AWS SSM? A: Yes you can, just be sure to have the correct permissions AWS-side and you're good to go. Q: Can I use Leapp AWS SSO sessions to issue AWS commands with my ? A: Yes you can, Leapp generates under the hood plain temporary credentials in your default profile. If for any reason you find some incompatibilities, please fill a new issue Q: I can't find my portal URL, when I try to access AWS SSO service it points me to presentation page but there is no admin console? A: To have access to AWS SSO console you must have privileges for that, please check your email or contact your administrator to obtain a portal URL. Q: Why there are no options to edit or delete AWS SSO accounts? A: AWS SSO management is done via AWS console by your administrator, you only have read access to the sessions, no need to edit or remove them. Q: I only see the name of the account and the role, can I recover other information for my work? A: Yes you can, you can copy the role arn and the account number from the contextual menu. Q: Can I use MFA with Leapp and AWS SSO? A: Yes, if your administrator has configured MFA for your AWS SSO account you'll be prompted for the code during authentication process. Q: I've installed Leapp, before I was using AWS SSO with CLI v2. It says my credentials are expired, what can I do? A: Clear cli/ folder, clear sso/ inside ~/.aws . Also, be sure to clean ~/.aws/config because it will probably contains data from your previous setup.","title":"FAQ"},{"location":"contributing/structure/integrations/","text":"Integrations The idea behind Integrations is to integrate external services into the Leapp's flow, in order to embrace your specific Use Case. For example, you could integrate Leapp's flow with an external Identity Provider where you store and manage your Users, or Keychain where you want your credentials to be stored in. Following this concept, we added support to AWS SSO; through this integration, Leapp is able to retrieve Session information and obtain temporary credentials associated to them.","title":"Integrations"},{"location":"contributing/structure/integrations/#integrations","text":"The idea behind Integrations is to integrate external services into the Leapp's flow, in order to embrace your specific Use Case. For example, you could integrate Leapp's flow with an external Identity Provider where you store and manage your Users, or Keychain where you want your credentials to be stored in. Following this concept, we added support to AWS SSO; through this integration, Leapp is able to retrieve Session information and obtain temporary credentials associated to them.","title":"Integrations"},{"location":"contributing/structure/overview/","text":"Overview To allow what is proposed in the Specs, Leapp's project is built on a set of services that realize the basic functionalities . The actual project's structure is structured to allow developers to contribute to source code in the most easier and atomic way possible. In particular, we want to focus the attention on the development of Session Service patterns: Session Service Pattern A specific service manages the way each type of Session will handle the process of credentials generation. There is a three-level abstraction implementation for this kind of service: A general Session Service is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate. A Provider Session Service (i.e., AWSSessionService ) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider. A Provider Access Method Service (i.e., AWSIAMUserService ) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method. AWS example Leapp manages on behalf of a user the ~./aws/credentials file. It leverages Start , Stop , and Rotate methods from basic Session Service to add, remove, or renew temporary credentials in the file. Based on the Session Service Pattern, we created the Aws Session Service to extend basic Session Service for AWS . AwsSessionService (Provider Service) AwsSessionService was created because all the Access Methods for AWS implemented in Leapp shares a common code structure for Start , Stop , and Rotate . AwsSessionService defines three abstract methods, that must be implemented by every Access Methods of AWS . They are: generateCredentials applyCredentials deApplyCredentials async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} Let's check Start, Stop, and Rotate in detail. Start() The start method is called when a user clicks on an AWS session in the Session List in the Client UI, and it marks the activation of a session thus generating and applying new temporary credentials. async start(sessionId: string): Promise<void> { try { this.stopAllWithSameNameProfile(sessionId); this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId);** **await this.applyCredentials(sessionId, credentialsInfo);** this.sessionActivate(sessionId); } catch (error) { this.sessionError(sessionId, error); } } Start method accept a sessionId parameter to retrieve the session to activate . Above is how the Start method is coded in AWS Session Service by means of a template . Using a template ensures that every Access Method for AWS, will need to implement only some specific parts of the code, without compromising the general logic. The steps included are: Stop all sessions with the same name profile - only one session can be activated with a specific profile name at a time. Put Session state to loading . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active using sessionActivate() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Rotate() async rotate(sessionId: string): Promise<void> { try { this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId); await this.applyCredentials(sessionId, credentialsInfo);** this.sessionRotated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } A similar approach to Start is used with Rotate. Rotate() is called by the Client every time a session is expired (temporary credentials are no longer valid). Calling Rotate will generate a new set of temporary credentials, replacing the old ones. The steps included are: Put Session state to loading . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active by calling the sessionRotated() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Stop() async stop(sessionId: string): Promise<void> { try { **await this.deApplyCredentials(sessionId);** this.sessionDeactivated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } The Stop method happens when an error occurs during a call or when the user clicks on an active session . In this case, we de-apply temporary credentials, which in the case of AWS, means removing them from the credential file. Steps here are: De-apply credentials - this method is overridden by specific implementations of Access Methods, usually involving operations other than removing credentials from credentials file, like removing sensible information from your Secret Vault because they are no longer used. Deactivate the session - which involves putting the Session' state to inactive . The Session will be moved from active session list to general session list in the UI . As always in case of error, we send general error information to the UI and to the log file via sessionError . To conclude, each Access Method has a specific service that extends AwsSessionService implementing these 3 common methods (generate, apply, and de-apply) . Access Method Session Service An Access Method generates credentials for the User access to a Cloud Provider , for example, in AWS we have different access methods: AWS IAM Users AWS IAM Roles Federated AWS IAM Role Chained AWS SSO Role. Each access method service implements actions to Create , Delete , and Edit this specific Session Type. As the first thing we need to create an interface of all the required information to a specific Access Method: export interface AwsPlainSessionRequest { accountName: string; accessKey: string; secretKey: string; region: string; mfaDevice?: string; } To set up a specific session from an Access Method we have to create it with a Create method, which uses the interface previously defined: create(accountRequest: AwsPlainSessionRequest, profileId: string): void { const session = new AwsPlainSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } At the moment edit and delete are defined generally in SessionService , so no need to implement them in an Access Method. To allow using other services to construct our logic we define them in the constructor of the service class. constructor( protected workspaceService: WorkspaceService, private keychainService: KeychainService, private appService: AppService, private fileService: FileService) { super(workspaceService); } We also need to define a super(workspaceService) as we are extending AwsSessionService, and thus its constructor. To fulfill its tasks an Access Method must extend AwsSessionService ; doing so, will require to implement these three methods: async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} They are mandatory , but besides them, a Developer can add to the service class every private or static method he/she would like to organize the code. We present AWS IAM Users Access Method implementation as an example . AWS IAM Users Access Method Below we present all the methods implemented in the AWS IAM User Access Method; its purpose is to build temporary IAM STS credentials starting from a standard IAM User credential set. The Set is stored securely upon session creation in the OS Vault and is used at runtime, and only here to generate valid IAM STS temporary credentials. Let's start with two helper methods: static isTokenExpired(tokenExpiration: string): boolean { const now = Date.now(); return now > new Date(tokenExpiration).getTime(); } With isTokenExpired we check the SessionToken expiration given with the temporary credentials to see if they are still valid or not (thus the method returning a boolean). static sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse: GetSessionTokenResponse): { sessionToken: any } { return { sessionToken: { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: getSessionTokenResponse.Credentials.AccessKeyId.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: getSessionTokenResponse.Credentials.SecretAccessKey.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: getSessionTokenResponse.Credentials.SessionToken.trim(), } }; } The second helper method constructs a CredentialInfo object to return to the AWSSessionService template for Start () and Rotate (). It is called at the end of the generateCredentials () *method *. It has the SessionTokenResponse from the STS client as the input parameter. It maps all the relevant attributes to the returned object. create(accountRequest: AwsIamUserSessionRequest, profileId: string): void { const session = new AwsIamUserSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } Create() is used to construct a new Session as explained before. It calls for a new AwsIamUserSession , passing the properties retrieved from the UI form. A Developer will define a new Model for a Session and that new model will be used here, in case he/she wants to create a new Access Method. In this particular case we also save the static credentials in the OS Vault using the KeyChain service, which makes saving and retrieving secrets from the vault transparent to the developer. Finally, we add the session to the workspace (our configuration object). async generateCredentials(sessionId: string): Promise<CredentialsInfo> { // Get the session in question const session = this.get(sessionId); // Retrieve session token expiration const tokenExpiration = (session as AwsIamUserSession).sessionTokenExpiration; // Check if token is expired if (!tokenExpiration || AwsIamUserService.isTokenExpired(tokenExpiration)) { // Token is Expired! // Retrieve access keys from keychain const accessKeyId = await this.getAccessKeyFromKeychain(sessionId); const secretAccessKey = await this.getSecretKeyFromKeychain(sessionId); // Get session token // https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html AWS.config.update({ accessKeyId, secretAccessKey }); // Configure sts client options const sts = new AWS.STS(this.appService.stsOptions(session)); // Configure sts get-session-token api call params // eslint-disable-next-line @typescript-eslint/naming-convention const params = { DurationSeconds: environment.sessionTokenDuration }; // Check if MFA is needed or not if ((session as AwsIamUserSession).mfaDevice) { // Return session token after calling MFA modal return this.generateSessionTokenCallingMfaModal(session, sts, params); } else { // Return session token in the form of CredentialsInfo return this.generateSessionToken(session, sts, params); } } else { // Session Token is NOT expired try { // Retrieve session token from keychain return JSON.parse(await this.keychainService.getSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`)); } catch (err) { throw new LeappParseError(this, err.message); } } } The first of the abstract methods we need to implement in the Access Method Service. We use this to generate credentials and return them in the form of a Javascript Promise - because the procedure is potentially not immediate and asynchronous. We retrieve the session previously created using the sessionId , which is passed as a parameter; from there we check its token expiration to see if we need to generate new credentials or reuse the one previously created. If we already have a valid session token, we retrieve it from the OS vault, parse the JSON string to construct a valid object to return for further processing. Note that when the return type is a Promise, any normal object will be directly cast to Promise . If we don't have any token expiration property (first generation) or the token is expired, we retrieve static credentials from the OS vault and use them in combination with the IAM STS client to generate a new Session Token with temporary credentials using this.generateSessionToken(session, sts, params); In case we have configured Multi-Factor Authentication, we call for a helper method to show a modal window, retrieve the MFA code, add it to the STS parameters and then obtain the session token. private generateSessionTokenCallingMfaModal( session: Session, sts: AWS.STS, params: { DurationSeconds: number }): Promise<CredentialsInfo> { return new Promise((resolve, reject) => { this.appService.inputDialog('MFA Code insert', 'Insert MFA Code', 'please insert MFA code from your app or device', (value) => { if (value !== Constants.confirmClosed) { params['SerialNumber'] = (session as AwsIamUserSession).mfaDevice; params['TokenCode'] = value; // Return session token in the form of CredentialsInfo resolve(this.generateSessionToken(session, sts, params)); } else { reject(new LeappMissingMfaTokenError(this, 'Missing Multi Factor Authentication code')); } }); }); } We can see that we return a promise to adhere to the generateCredentials signature. async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialObject = {}; credentialObject[profileName] = { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: credentialsInfo.sessionToken.aws_access_key_id, // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: credentialsInfo.sessionToken.aws_secret_access_key, // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: credentialsInfo.sessionToken.aws_session_token, region: session.region }; return await this.fileService.iniWriteSync(this.appService.awsCredentialPath(), credentialObject); } Applying credentials is just a matter of getting the current profile name for the session, construct a suitable credential object using the profile name and the CredentialInfo object from generateCredentials and write it in the AWS credential file. async deApplyCredentials(sessionId: string): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialsFile = await this.fileService.iniParseSync(this.appService.awsCredentialPath()); delete credentialsFile[profileName]; return await this.fileService.replaceWriteSync(this.appService.awsCredentialPath(), credentialsFile); } To de-apply a credential we retrieve its profile name and use it to find and remove the credential set from the credential file. private async getAccessKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-access-key-id`); } private async getSecretKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-secret-access-key`); } private async generateSessionToken(session: Session, sts: AWS.STS, params: any): Promise<CredentialsInfo> { try { // Invoke sts get-session-token api const getSessionTokenResponse: GetSessionTokenResponse = await sts.getSessionToken(params).promise(); // Save session token expiration this.saveSessionTokenResponseInTheSession(session, getSessionTokenResponse); // Generate correct object from session token response const sessionToken = AwsIamUserService.sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse); // Save in keychain the session token await this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`, JSON.stringify(sessionToken)); // Return Session Token return sessionToken; } catch (err) { throw new LeappAwsStsError(this, err.message); } } The first two methods are used to simplify getting secrets in the OS vault. generateSessionToken () is used to call STS for generating a new session, save the expiration time from token in the session, save the session token in the OS vault and finally return the session token for further processing. private saveSessionTokenResponseInTheSession(session: Session, getSessionTokenResponse: AWS.STS.GetSessionTokenResponse): void { const index = this.workspaceService.sessions.indexOf(session); const currentSession: Session = this.workspaceService.sessions[index]; (currentSession as AwsIamUserSession).sessionTokenExpiration = getSessionTokenResponse.Credentials.Expiration.toISOString(); this.workspaceService.sessions[index] = currentSession; this.workspaceService.sessions = [...this.workspaceService.sessions]; } This helper method is used to extract the session token expiration and save it as a property of the session object to later use it in case of a further generation of credentials, both during a rotation event or a manual re-apply.","title":"Overview"},{"location":"contributing/structure/overview/#overview","text":"To allow what is proposed in the Specs, Leapp's project is built on a set of services that realize the basic functionalities . The actual project's structure is structured to allow developers to contribute to source code in the most easier and atomic way possible. In particular, we want to focus the attention on the development of Session Service patterns:","title":"Overview"},{"location":"contributing/structure/overview/#session-service-pattern","text":"A specific service manages the way each type of Session will handle the process of credentials generation. There is a three-level abstraction implementation for this kind of service: A general Session Service is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate. A Provider Session Service (i.e., AWSSessionService ) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider. A Provider Access Method Service (i.e., AWSIAMUserService ) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method.","title":"Session Service Pattern"},{"location":"contributing/structure/overview/#aws-example","text":"Leapp manages on behalf of a user the ~./aws/credentials file. It leverages Start , Stop , and Rotate methods from basic Session Service to add, remove, or renew temporary credentials in the file. Based on the Session Service Pattern, we created the Aws Session Service to extend basic Session Service for AWS .","title":"AWS example"},{"location":"contributing/structure/overview/#awssessionservice-provider-service","text":"AwsSessionService was created because all the Access Methods for AWS implemented in Leapp shares a common code structure for Start , Stop , and Rotate . AwsSessionService defines three abstract methods, that must be implemented by every Access Methods of AWS . They are: generateCredentials applyCredentials deApplyCredentials async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} Let's check Start, Stop, and Rotate in detail. Start() The start method is called when a user clicks on an AWS session in the Session List in the Client UI, and it marks the activation of a session thus generating and applying new temporary credentials. async start(sessionId: string): Promise<void> { try { this.stopAllWithSameNameProfile(sessionId); this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId);** **await this.applyCredentials(sessionId, credentialsInfo);** this.sessionActivate(sessionId); } catch (error) { this.sessionError(sessionId, error); } } Start method accept a sessionId parameter to retrieve the session to activate . Above is how the Start method is coded in AWS Session Service by means of a template . Using a template ensures that every Access Method for AWS, will need to implement only some specific parts of the code, without compromising the general logic. The steps included are: Stop all sessions with the same name profile - only one session can be activated with a specific profile name at a time. Put Session state to loading . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active using sessionActivate() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Rotate() async rotate(sessionId: string): Promise<void> { try { this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId); await this.applyCredentials(sessionId, credentialsInfo);** this.sessionRotated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } A similar approach to Start is used with Rotate. Rotate() is called by the Client every time a session is expired (temporary credentials are no longer valid). Calling Rotate will generate a new set of temporary credentials, replacing the old ones. The steps included are: Put Session state to loading . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active by calling the sessionRotated() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Stop() async stop(sessionId: string): Promise<void> { try { **await this.deApplyCredentials(sessionId);** this.sessionDeactivated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } The Stop method happens when an error occurs during a call or when the user clicks on an active session . In this case, we de-apply temporary credentials, which in the case of AWS, means removing them from the credential file. Steps here are: De-apply credentials - this method is overridden by specific implementations of Access Methods, usually involving operations other than removing credentials from credentials file, like removing sensible information from your Secret Vault because they are no longer used. Deactivate the session - which involves putting the Session' state to inactive . The Session will be moved from active session list to general session list in the UI . As always in case of error, we send general error information to the UI and to the log file via sessionError . To conclude, each Access Method has a specific service that extends AwsSessionService implementing these 3 common methods (generate, apply, and de-apply) .","title":"AwsSessionService (Provider Service)"},{"location":"contributing/structure/overview/#access-method-session-service","text":"An Access Method generates credentials for the User access to a Cloud Provider , for example, in AWS we have different access methods: AWS IAM Users AWS IAM Roles Federated AWS IAM Role Chained AWS SSO Role. Each access method service implements actions to Create , Delete , and Edit this specific Session Type. As the first thing we need to create an interface of all the required information to a specific Access Method: export interface AwsPlainSessionRequest { accountName: string; accessKey: string; secretKey: string; region: string; mfaDevice?: string; } To set up a specific session from an Access Method we have to create it with a Create method, which uses the interface previously defined: create(accountRequest: AwsPlainSessionRequest, profileId: string): void { const session = new AwsPlainSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } At the moment edit and delete are defined generally in SessionService , so no need to implement them in an Access Method. To allow using other services to construct our logic we define them in the constructor of the service class. constructor( protected workspaceService: WorkspaceService, private keychainService: KeychainService, private appService: AppService, private fileService: FileService) { super(workspaceService); } We also need to define a super(workspaceService) as we are extending AwsSessionService, and thus its constructor. To fulfill its tasks an Access Method must extend AwsSessionService ; doing so, will require to implement these three methods: async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} They are mandatory , but besides them, a Developer can add to the service class every private or static method he/she would like to organize the code. We present AWS IAM Users Access Method implementation as an example .","title":"Access Method Session Service"},{"location":"contributing/structure/overview/#aws-iam-users-access-method","text":"Below we present all the methods implemented in the AWS IAM User Access Method; its purpose is to build temporary IAM STS credentials starting from a standard IAM User credential set. The Set is stored securely upon session creation in the OS Vault and is used at runtime, and only here to generate valid IAM STS temporary credentials. Let's start with two helper methods: static isTokenExpired(tokenExpiration: string): boolean { const now = Date.now(); return now > new Date(tokenExpiration).getTime(); } With isTokenExpired we check the SessionToken expiration given with the temporary credentials to see if they are still valid or not (thus the method returning a boolean). static sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse: GetSessionTokenResponse): { sessionToken: any } { return { sessionToken: { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: getSessionTokenResponse.Credentials.AccessKeyId.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: getSessionTokenResponse.Credentials.SecretAccessKey.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: getSessionTokenResponse.Credentials.SessionToken.trim(), } }; } The second helper method constructs a CredentialInfo object to return to the AWSSessionService template for Start () and Rotate (). It is called at the end of the generateCredentials () *method *. It has the SessionTokenResponse from the STS client as the input parameter. It maps all the relevant attributes to the returned object. create(accountRequest: AwsIamUserSessionRequest, profileId: string): void { const session = new AwsIamUserSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } Create() is used to construct a new Session as explained before. It calls for a new AwsIamUserSession , passing the properties retrieved from the UI form. A Developer will define a new Model for a Session and that new model will be used here, in case he/she wants to create a new Access Method. In this particular case we also save the static credentials in the OS Vault using the KeyChain service, which makes saving and retrieving secrets from the vault transparent to the developer. Finally, we add the session to the workspace (our configuration object). async generateCredentials(sessionId: string): Promise<CredentialsInfo> { // Get the session in question const session = this.get(sessionId); // Retrieve session token expiration const tokenExpiration = (session as AwsIamUserSession).sessionTokenExpiration; // Check if token is expired if (!tokenExpiration || AwsIamUserService.isTokenExpired(tokenExpiration)) { // Token is Expired! // Retrieve access keys from keychain const accessKeyId = await this.getAccessKeyFromKeychain(sessionId); const secretAccessKey = await this.getSecretKeyFromKeychain(sessionId); // Get session token // https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html AWS.config.update({ accessKeyId, secretAccessKey }); // Configure sts client options const sts = new AWS.STS(this.appService.stsOptions(session)); // Configure sts get-session-token api call params // eslint-disable-next-line @typescript-eslint/naming-convention const params = { DurationSeconds: environment.sessionTokenDuration }; // Check if MFA is needed or not if ((session as AwsIamUserSession).mfaDevice) { // Return session token after calling MFA modal return this.generateSessionTokenCallingMfaModal(session, sts, params); } else { // Return session token in the form of CredentialsInfo return this.generateSessionToken(session, sts, params); } } else { // Session Token is NOT expired try { // Retrieve session token from keychain return JSON.parse(await this.keychainService.getSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`)); } catch (err) { throw new LeappParseError(this, err.message); } } } The first of the abstract methods we need to implement in the Access Method Service. We use this to generate credentials and return them in the form of a Javascript Promise - because the procedure is potentially not immediate and asynchronous. We retrieve the session previously created using the sessionId , which is passed as a parameter; from there we check its token expiration to see if we need to generate new credentials or reuse the one previously created. If we already have a valid session token, we retrieve it from the OS vault, parse the JSON string to construct a valid object to return for further processing. Note that when the return type is a Promise, any normal object will be directly cast to Promise . If we don't have any token expiration property (first generation) or the token is expired, we retrieve static credentials from the OS vault and use them in combination with the IAM STS client to generate a new Session Token with temporary credentials using this.generateSessionToken(session, sts, params); In case we have configured Multi-Factor Authentication, we call for a helper method to show a modal window, retrieve the MFA code, add it to the STS parameters and then obtain the session token. private generateSessionTokenCallingMfaModal( session: Session, sts: AWS.STS, params: { DurationSeconds: number }): Promise<CredentialsInfo> { return new Promise((resolve, reject) => { this.appService.inputDialog('MFA Code insert', 'Insert MFA Code', 'please insert MFA code from your app or device', (value) => { if (value !== Constants.confirmClosed) { params['SerialNumber'] = (session as AwsIamUserSession).mfaDevice; params['TokenCode'] = value; // Return session token in the form of CredentialsInfo resolve(this.generateSessionToken(session, sts, params)); } else { reject(new LeappMissingMfaTokenError(this, 'Missing Multi Factor Authentication code')); } }); }); } We can see that we return a promise to adhere to the generateCredentials signature. async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialObject = {}; credentialObject[profileName] = { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: credentialsInfo.sessionToken.aws_access_key_id, // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: credentialsInfo.sessionToken.aws_secret_access_key, // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: credentialsInfo.sessionToken.aws_session_token, region: session.region }; return await this.fileService.iniWriteSync(this.appService.awsCredentialPath(), credentialObject); } Applying credentials is just a matter of getting the current profile name for the session, construct a suitable credential object using the profile name and the CredentialInfo object from generateCredentials and write it in the AWS credential file. async deApplyCredentials(sessionId: string): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialsFile = await this.fileService.iniParseSync(this.appService.awsCredentialPath()); delete credentialsFile[profileName]; return await this.fileService.replaceWriteSync(this.appService.awsCredentialPath(), credentialsFile); } To de-apply a credential we retrieve its profile name and use it to find and remove the credential set from the credential file. private async getAccessKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-access-key-id`); } private async getSecretKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-secret-access-key`); } private async generateSessionToken(session: Session, sts: AWS.STS, params: any): Promise<CredentialsInfo> { try { // Invoke sts get-session-token api const getSessionTokenResponse: GetSessionTokenResponse = await sts.getSessionToken(params).promise(); // Save session token expiration this.saveSessionTokenResponseInTheSession(session, getSessionTokenResponse); // Generate correct object from session token response const sessionToken = AwsIamUserService.sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse); // Save in keychain the session token await this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`, JSON.stringify(sessionToken)); // Return Session Token return sessionToken; } catch (err) { throw new LeappAwsStsError(this, err.message); } } The first two methods are used to simplify getting secrets in the OS vault. generateSessionToken () is used to call STS for generating a new session, save the expiration time from token in the session, save the session token in the OS vault and finally return the session token for further processing. private saveSessionTokenResponseInTheSession(session: Session, getSessionTokenResponse: AWS.STS.GetSessionTokenResponse): void { const index = this.workspaceService.sessions.indexOf(session); const currentSession: Session = this.workspaceService.sessions[index]; (currentSession as AwsIamUserSession).sessionTokenExpiration = getSessionTokenResponse.Credentials.Expiration.toISOString(); this.workspaceService.sessions[index] = currentSession; this.workspaceService.sessions = [...this.workspaceService.sessions]; } This helper method is used to extract the session token expiration and save it as a property of the session object to later use it in case of a further generation of credentials, both during a rotation event or a manual re-apply.","title":"AWS IAM Users Access Method"},{"location":"contributing/structure/system_vault/","text":"Vault Strategy We use Keytar as a library to maintain a secure vault for sensitive data. Prerequisite for using on Linux systems Currently this library uses libsecret so you may need to install it before running Leapp. Depending on your distribution, you will need to run the following command: Debian/Ubuntu: sudo apt-get install libsecret-1-dev Red Hat-based: sudo yum install libsecret-devel Arch Linux: sudo pacman -S libsecret Supported versions for contributors Each release of keytar includes prebuilt binaries for the versions of Node and Electron that are actively supported by our project. Please refer to the release documentation for Node and Electron to see what is supported currently. Keytar documentation Every function in keytar is asynchronous and returns a Promise . The promise will be rejected with any error that occurs or will be resolved within the function's yields value. In Leapp we use the three methods listed below to save and store sensible information and to avoid keeping them anywhere in the code. The delete function is used when an AWS Plain session is updated or removed from the list. getPassword(service, account) Get the stored password for the service and account . service - The string service name. account - The string account name. Yields the string password or null if an entry for the given service and account was not found. setPassword(service, account, password) Save the password for the service and account to the keychain. Adds a new entry if necessary, or updates an existing entry if one exists. service - The string service name. account - The string account name. password - The string password. Yields nothing. deletePassword(service, account) Delete the stored password for the service and account . service - The string service name. account - The string account name. Yields true if a password was deleted, or false if an entry with the given service and account was not found. How can I find Leapp data in the Vault? Every key stored by Leapp in the vault is named Leapp . The account name shows the description of the element saved by our software. How Keytar translate to system vaults? Keytar translate to the following system vaults depending on the OS: On macOS the passwords are managed by the Keychain . On Linux they are managed by the Secret Service API/libsecret . On Windows they are managed by Credential Vault .","title":"System Vault"},{"location":"contributing/structure/system_vault/#vault-strategy","text":"We use Keytar as a library to maintain a secure vault for sensitive data.","title":"Vault Strategy"},{"location":"contributing/structure/system_vault/#prerequisite-for-using-on-linux-systems","text":"Currently this library uses libsecret so you may need to install it before running Leapp. Depending on your distribution, you will need to run the following command: Debian/Ubuntu: sudo apt-get install libsecret-1-dev Red Hat-based: sudo yum install libsecret-devel Arch Linux: sudo pacman -S libsecret","title":"Prerequisite for using on Linux systems"},{"location":"contributing/structure/system_vault/#supported-versions-for-contributors","text":"Each release of keytar includes prebuilt binaries for the versions of Node and Electron that are actively supported by our project. Please refer to the release documentation for Node and Electron to see what is supported currently.","title":"Supported versions for contributors"},{"location":"contributing/structure/system_vault/#keytar-documentation","text":"Every function in keytar is asynchronous and returns a Promise . The promise will be rejected with any error that occurs or will be resolved within the function's yields value. In Leapp we use the three methods listed below to save and store sensible information and to avoid keeping them anywhere in the code. The delete function is used when an AWS Plain session is updated or removed from the list.","title":"Keytar documentation"},{"location":"contributing/structure/system_vault/#getpasswordservice-account","text":"Get the stored password for the service and account . service - The string service name. account - The string account name. Yields the string password or null if an entry for the given service and account was not found.","title":"getPassword(service, account)"},{"location":"contributing/structure/system_vault/#setpasswordservice-account-password","text":"Save the password for the service and account to the keychain. Adds a new entry if necessary, or updates an existing entry if one exists. service - The string service name. account - The string account name. password - The string password. Yields nothing.","title":"setPassword(service, account, password)"},{"location":"contributing/structure/system_vault/#deletepasswordservice-account","text":"Delete the stored password for the service and account . service - The string service name. account - The string account name. Yields true if a password was deleted, or false if an entry with the given service and account was not found.","title":"deletePassword(service, account)"},{"location":"contributing/structure/system_vault/#how-can-i-find-leapp-data-in-the-vault","text":"Every key stored by Leapp in the vault is named Leapp . The account name shows the description of the element saved by our software.","title":"How can I find Leapp data in the Vault?"},{"location":"contributing/structure/system_vault/#how-keytar-translate-to-system-vaults","text":"Keytar translate to the following system vaults depending on the OS: On macOS the passwords are managed by the Keychain . On Linux they are managed by the Secret Service API/libsecret . On Windows they are managed by Credential Vault .","title":"How Keytar translate to system vaults?"},{"location":"contributing/structure/updater/","text":"Leapp Updater Leapp update system checks every 10 minutes (counting from App start) that a new version is available. If so, a dialog message will pop up and will show: The version number The release date The changelog In this modal, the users have the possibility to: Remind me later : Leapp will shut down the modal, notify the user that a new update is available by changing the Tray icon (adding a red dot) . Now users will not be bothered anymore until the next release is available. This option is suitable for users that want to stick to a specific version . Note that you can do this for every version and maintain the one you prefer. Download update : Leapp will open the Release URL in your default browser to let the User manually download the release for the specific OS and install it. How the Update System works in details 1) In Electron inside app ready we launch autoUpdater polling. app.on('ready', () => { autoUpdater.checkForUpdates(); }); autoUpdater.on('update-available', (info) => { win.webContents.send('UPDATE_AVAILABLE', info); }); 2) In the Electron app start after auto-update we listen to the update-available event. 3) We communicate with Angular informing us that an update is available and we also send info about the update (changelog, date, and version). 4) Inside the app component , which is the entry point of the Angular application, we use a method to listen to Electron notification about an update being available. 5) During this process we also check the status of latest.json, which is a file that is written on app start. It contains the current version of Leapp or the latest version we refused with the 'remind me later' option . a. if the file doesn't exist Leapp creates it with the current version. b. if the file exists Leapp reads the saved version. c. now we have a saved version: we confront it with the actual version retrieved from package.json. d. if the saved version is \u2264 of the actual version (package.json) we can overwrite the value in the file. This operation ensures a specific case: You have the current one saved into the file: typically is when you never had an update over the current version, so you store the current version which will be < of a new update. This avoids overwriting the value of latest.json if you have already declined an update. 6) We retrieve ipcRenderer for the previous passages, thanks to the Native Service file, so we can read our UPDATE_AVAILABLE channel. const ipc = this.app.getIpcRenderer(); ipc.on('UPDATE_AVAILABLE', (event, info) => { ... }); 7) We receive an update from Electron with the update's info. 8) setUpdateInfo saves only the variables we need inside the updater service because we want to use them later, without passing them externally, to make all the methods inside the service callable everywhere transparently. 9) We check the current saved version (in the file) with the one retrieved from the update if < we call the update dialog and refresh the tray icon graphic. 10) In the update modal we show the changelog and the version as well as having two buttons, one for Remind me later , and one for Download now . 1) Remind me later is used to close the modal and return an event of type 'ignore the update'. 2) Download update closes the modal and returns an event of type 'download from URL'. 11) We read the event in the close callback of the modal from the updater service, if 'ignore', we save the updated version in the file to prevent other updates to show up, or if 'download', we go to the update page on GitHub. 12) When we ignore an update, we add the ability to call the update dialog again from the tray menu. Notes We have the following options for autoUpdater set on FALSE : autoUpdater.allowDowngrade = false; autoUpdater.allowPrerelease = false; autoUpdater.autoDownload = false; The rule of thumb is fresh \u2264 cache \u2264 online .","title":"Updater"},{"location":"contributing/structure/updater/#leapp-updater","text":"Leapp update system checks every 10 minutes (counting from App start) that a new version is available. If so, a dialog message will pop up and will show: The version number The release date The changelog In this modal, the users have the possibility to: Remind me later : Leapp will shut down the modal, notify the user that a new update is available by changing the Tray icon (adding a red dot) . Now users will not be bothered anymore until the next release is available. This option is suitable for users that want to stick to a specific version . Note that you can do this for every version and maintain the one you prefer. Download update : Leapp will open the Release URL in your default browser to let the User manually download the release for the specific OS and install it.","title":"Leapp Updater"},{"location":"contributing/structure/updater/#how-the-update-system-works-in-details","text":"1) In Electron inside app ready we launch autoUpdater polling. app.on('ready', () => { autoUpdater.checkForUpdates(); }); autoUpdater.on('update-available', (info) => { win.webContents.send('UPDATE_AVAILABLE', info); }); 2) In the Electron app start after auto-update we listen to the update-available event. 3) We communicate with Angular informing us that an update is available and we also send info about the update (changelog, date, and version). 4) Inside the app component , which is the entry point of the Angular application, we use a method to listen to Electron notification about an update being available. 5) During this process we also check the status of latest.json, which is a file that is written on app start. It contains the current version of Leapp or the latest version we refused with the 'remind me later' option . a. if the file doesn't exist Leapp creates it with the current version. b. if the file exists Leapp reads the saved version. c. now we have a saved version: we confront it with the actual version retrieved from package.json. d. if the saved version is \u2264 of the actual version (package.json) we can overwrite the value in the file. This operation ensures a specific case: You have the current one saved into the file: typically is when you never had an update over the current version, so you store the current version which will be < of a new update. This avoids overwriting the value of latest.json if you have already declined an update. 6) We retrieve ipcRenderer for the previous passages, thanks to the Native Service file, so we can read our UPDATE_AVAILABLE channel. const ipc = this.app.getIpcRenderer(); ipc.on('UPDATE_AVAILABLE', (event, info) => { ... }); 7) We receive an update from Electron with the update's info. 8) setUpdateInfo saves only the variables we need inside the updater service because we want to use them later, without passing them externally, to make all the methods inside the service callable everywhere transparently. 9) We check the current saved version (in the file) with the one retrieved from the update if < we call the update dialog and refresh the tray icon graphic. 10) In the update modal we show the changelog and the version as well as having two buttons, one for Remind me later , and one for Download now . 1) Remind me later is used to close the modal and return an event of type 'ignore the update'. 2) Download update closes the modal and returns an event of type 'download from URL'. 11) We read the event in the close callback of the modal from the updater service, if 'ignore', we save the updated version in the file to prevent other updates to show up, or if 'download', we go to the update page on GitHub. 12) When we ignore an update, we add the ability to call the update dialog again from the tray menu.","title":"How the Update System works in details"},{"location":"contributing/structure/updater/#notes","text":"We have the following options for autoUpdater set on FALSE : autoUpdater.allowDowngrade = false; autoUpdater.allowPrerelease = false; autoUpdater.autoDownload = false; The rule of thumb is fresh \u2264 cache \u2264 online .","title":"Notes"},{"location":"tutorials/first_access/","text":"First Launch Setup When you first launch Leapp you'll be asked to set up a new Session for generating credentials. You'll be presented with the following scheme: If you select \" AWS \" Cloud Provider you'll be presented with an Access Method selection screen, the only Method disabled is IAM Role Chained, instead you'll have the choice to select \" IAM Federated Role \" or \" IAM User \": Either you choose one of them, please follow these other tutorials: How to create a IAM Federated Role Access Method for AWS with Leapp How to create a IAM User Access Method for AWS with Leapp If you select \"Azure\" you'll have to follow the following tutorial: How to create an Azure Access Method from Azure AD with Leapp After completing the setup you'll be presented with the list of sessions available to you to connect to:","title":"First Access"},{"location":"tutorials/first_access/#first-launch-setup","text":"When you first launch Leapp you'll be asked to set up a new Session for generating credentials. You'll be presented with the following scheme: If you select \" AWS \" Cloud Provider you'll be presented with an Access Method selection screen, the only Method disabled is IAM Role Chained, instead you'll have the choice to select \" IAM Federated Role \" or \" IAM User \": Either you choose one of them, please follow these other tutorials: How to create a IAM Federated Role Access Method for AWS with Leapp How to create a IAM User Access Method for AWS with Leapp If you select \"Azure\" you'll have to follow the following tutorial: How to create an Azure Access Method from Azure AD with Leapp After completing the setup you'll be presented with the list of sessions available to you to connect to:","title":"First Launch Setup"},{"location":"tutorials/aws/aws_sso/","text":"Setup AWS SSO Role Access Method for Leapp To start using AWS SSO in Leapp you first need to retrieve two information from your AWS account: the Portal URL and the AWS SSO region . Portal URL : the AWS SSO user portal is a central place where users can see and access their assigned AWS accounts, roles, and applications. Providing an AWS SSO user portal URL allows to integrate AWS and third-party applications like Leapp. To retrieve it check the email your administrator has send you containing the portal URL. AWS SSO region : this is the region where you have configured your AWS SSO. You can retrieve the region easily from AWS console or by contacting your administrator. Now you can go to your Leapp Application and add your AWS SSO configuration in two scenarios: 1) First time access : as you're accessing Leapp for the first time you can choose to configure all of your session directly from AWS SSO. To do so press Start and go to the next screen. In the next screen select AWS SSO like in the picture below: In the following screen insert the portal url and the region . then press the AWS SSO button. if everything is correct you'll be prompted with the following screen: Click on the orange button, and Leapp will connect to your AWS SSO portal retrieving all the sessions for you. 2) You already have some sessions : to add sessions from your AWS SSO portal, go to the option menu clicking on the azure hamburger button on the top-left of Leapp header . From the sidebar men\u00f9 choose integration - Identity Provider like in the screenshot below: In the following screen insert the portal url and the region . then press the AWS SSO button. if everything is correct you'll be prompted with the following screen: Click on the orange button and Leapp will connect to your AWS SSO portal retrieving all the sessions for you.","title":"AWS SSO"},{"location":"tutorials/aws/aws_sso/#setup-aws-sso-role-access-method-for-leapp","text":"To start using AWS SSO in Leapp you first need to retrieve two information from your AWS account: the Portal URL and the AWS SSO region . Portal URL : the AWS SSO user portal is a central place where users can see and access their assigned AWS accounts, roles, and applications. Providing an AWS SSO user portal URL allows to integrate AWS and third-party applications like Leapp. To retrieve it check the email your administrator has send you containing the portal URL. AWS SSO region : this is the region where you have configured your AWS SSO. You can retrieve the region easily from AWS console or by contacting your administrator. Now you can go to your Leapp Application and add your AWS SSO configuration in two scenarios: 1) First time access : as you're accessing Leapp for the first time you can choose to configure all of your session directly from AWS SSO. To do so press Start and go to the next screen. In the next screen select AWS SSO like in the picture below: In the following screen insert the portal url and the region . then press the AWS SSO button. if everything is correct you'll be prompted with the following screen: Click on the orange button, and Leapp will connect to your AWS SSO portal retrieving all the sessions for you. 2) You already have some sessions : to add sessions from your AWS SSO portal, go to the option menu clicking on the azure hamburger button on the top-left of Leapp header . From the sidebar men\u00f9 choose integration - Identity Provider like in the screenshot below: In the following screen insert the portal url and the region . then press the AWS SSO button. if everything is correct you'll be prompted with the following screen: Click on the orange button and Leapp will connect to your AWS SSO portal retrieving all the sessions for you.","title":"Setup AWS SSO Role Access Method for Leapp"},{"location":"tutorials/aws/iam_user_setup/","text":"How to create a IAM User Access Method for AWS If this is your first time accessing Leapp please follow this guide . 1) From your quick list click on the \"+\" button located on the top-right corner of the app You'll be presented with the Provider Selection screen: 2) Choose \" AWS \" as a Cloud Provider, than you'll be presented with the Access Strategy selection screen: Select \" IAM User \" as the Access Strategy. 3) As the last screen you'll be presented with the actual account creation screen: Session Alias: choose a unique name suitable to recognize the Access Method. MFA Device : Get it from your IAM User if any: check for its role ARN or if from a physical device its serial number . Region : The AWS Region you want your credentials to work on. Access Key / Secret Key: get the credentials from your IAM User. Here you can also set a new MFA device by clicking on \"Manage\" in the AWS console at the voice Assigned MFA device . IF an MFA arn is inserted in the form field, then Leapp will ask for MFA token before trying to generate temporary credentials. Please also refer to this section about limits in the plain account. Finally press Save .","title":"IAM User"},{"location":"tutorials/aws/iam_user_setup/#how-to-create-a-iam-user-access-method-for-aws","text":"If this is your first time accessing Leapp please follow this guide . 1) From your quick list click on the \"+\" button located on the top-right corner of the app You'll be presented with the Provider Selection screen: 2) Choose \" AWS \" as a Cloud Provider, than you'll be presented with the Access Strategy selection screen: Select \" IAM User \" as the Access Strategy. 3) As the last screen you'll be presented with the actual account creation screen: Session Alias: choose a unique name suitable to recognize the Access Method. MFA Device : Get it from your IAM User if any: check for its role ARN or if from a physical device its serial number . Region : The AWS Region you want your credentials to work on. Access Key / Secret Key: get the credentials from your IAM User. Here you can also set a new MFA device by clicking on \"Manage\" in the AWS console at the voice Assigned MFA device . IF an MFA arn is inserted in the form field, then Leapp will ask for MFA token before trying to generate temporary credentials. Please also refer to this section about limits in the plain account. Finally press Save .","title":"How to create a IAM User Access Method for AWS"},{"location":"tutorials/aws/ssm/","text":"How to connect to an EC2 instance through Leapp using AWS SSM Prerequisites In order to connect properly to a remote EC2 instance using SSM is necessary to configure the agent and appropriate permissions via AWS console . To configure access to one or more instances through SSM, follow the steps defined in this guide . In particular, you'll also want to check: - How to set up an SSM Agent for Linux EC2 instances - How to set up an SSM Agent for MacOS EC2 instances - How to set up an SSM Agent for Windows EC2 instances By default, AWS Systems Manager doesn't have permission to connect to your instances. You must grant access by using an AWS IAM instance profile. To do so, follow this step . Launching an AWS SSM Session using Leapp With Leapp it is possible to launch a remote session over an AWS EC2 instance by simply clicking on the kebab menu near the session information like in the figure. In the context menu, choose SSM Session . In the modal that should open select the region in which your EC2 instance resides. After loading all the available instances in that region, it will be possible to connect. After selecting the region if one or more instances are available you can SSM into that by clicking the connect button. Note that Leapp will not check if you're are eligible or not to connect, so in case of error, Leapp will stop the procedure telling what went wrong. In case you have to manage many sessions you can always use the general search bar to filter the specific session you need. After clicking connect, a terminal will pop up on your system connecting to the selected instance. Once connected you should see a screen similar to this: Here you'll have to type /bin/bash in order to fully connect to the machine. After that, you'll have complete remote access to the instance.","title":"AWS SSM Connect"},{"location":"tutorials/aws/ssm/#how-to-connect-to-an-ec2-instance-through-leapp-using-aws-ssm","text":"","title":"How to connect to an EC2 instance through Leapp using AWS SSM"},{"location":"tutorials/aws/ssm/#prerequisites","text":"In order to connect properly to a remote EC2 instance using SSM is necessary to configure the agent and appropriate permissions via AWS console . To configure access to one or more instances through SSM, follow the steps defined in this guide . In particular, you'll also want to check: - How to set up an SSM Agent for Linux EC2 instances - How to set up an SSM Agent for MacOS EC2 instances - How to set up an SSM Agent for Windows EC2 instances By default, AWS Systems Manager doesn't have permission to connect to your instances. You must grant access by using an AWS IAM instance profile. To do so, follow this step .","title":"Prerequisites"},{"location":"tutorials/aws/ssm/#launching-an-aws-ssm-session-using-leapp","text":"With Leapp it is possible to launch a remote session over an AWS EC2 instance by simply clicking on the kebab menu near the session information like in the figure. In the context menu, choose SSM Session . In the modal that should open select the region in which your EC2 instance resides. After loading all the available instances in that region, it will be possible to connect. After selecting the region if one or more instances are available you can SSM into that by clicking the connect button. Note that Leapp will not check if you're are eligible or not to connect, so in case of error, Leapp will stop the procedure telling what went wrong. In case you have to manage many sessions you can always use the general search bar to filter the specific session you need. After clicking connect, a terminal will pop up on your system connecting to the selected instance. Once connected you should see a screen similar to this: Here you'll have to type /bin/bash in order to fully connect to the machine. After that, you'll have complete remote access to the instance.","title":"Launching an AWS SSM Session using Leapp"},{"location":"tutorials/aws/chained/leapp_chained_setup/","text":"How to create a Truster Account from a Federated Account for AWS with Leapp NOTE : to create a chained session you either need a Federated, Plain, or SSO session first. If this is your first time accessing Leapp please follow this guide . 1. From your quick list click on the \"+\" button located on the top-right corner of the app You'll be presented with the Provider Selection screen: 2. Choose \" AWS \" as a Cloud Provider, then you'll be presented with the Access Method selection screen: Select \" IAM Chained Role \" as the Access Strategy. 3. As the last screen you'll be presented with the actual account creation screen: AWS Profile : here you can select (ora add by writing and pressing ENTER) a named profile to use for this credential set, base one is \"default\" Session Alias: choose a unique name suitable to recognize the Access Method. Region : the region to start this credential set into once the section is active. You can always add a default one from option panel Role ARN : Write the role ARN of the chained role you want to assume inside your AWS Account. Assumer Session : any eligible session that you can use to start your chained session. Finally press Save .","title":"Setup Leapp Chained"},{"location":"tutorials/aws/chained/leapp_chained_setup/#how-to-create-a-truster-account-from-a-federated-account-for-aws-with-leapp","text":"NOTE : to create a chained session you either need a Federated, Plain, or SSO session first. If this is your first time accessing Leapp please follow this guide .","title":"How to create a Truster Account from a Federated Account for AWS with Leapp"},{"location":"tutorials/aws/chained/leapp_chained_setup/#1-from-your-quick-list-click-on-the-button-located-on-the-top-right-corner-of-the-app","text":"You'll be presented with the Provider Selection screen:","title":"1. From your quick list click on the \"+\" button located on the top-right corner of the app"},{"location":"tutorials/aws/chained/leapp_chained_setup/#2-choose-aws-as-a-cloud-provider-then-youll-be-presented-with-the-access-method-selection-screen","text":"Select \" IAM Chained Role \" as the Access Strategy.","title":"2. Choose \"AWS\" as a Cloud Provider, then you'll be presented with the Access Method selection screen:"},{"location":"tutorials/aws/chained/leapp_chained_setup/#3-as-the-last-screen-youll-be-presented-with-the-actual-account-creation-screen","text":"AWS Profile : here you can select (ora add by writing and pressing ENTER) a named profile to use for this credential set, base one is \"default\" Session Alias: choose a unique name suitable to recognize the Access Method. Region : the region to start this credential set into once the section is active. You can always add a default one from option panel Role ARN : Write the role ARN of the chained role you want to assume inside your AWS Account. Assumer Session : any eligible session that you can use to start your chained session. Finally press Save .","title":"3. As the last screen you'll be presented with the actual account creation screen:"},{"location":"tutorials/aws/chained/trust_setup/","text":"Create Trust Relationship between an AWS Federated Role and an AWS Chained Role Create a new Chained Role in the AWS Truster Account 1. Go to the IAM console Go to the IAM console in your AWS Account and select Roles from the left-side column. 2. Create role Click on Create Role and select Another AWS account as the type of trusted entity; then, specify the Account ID (i.e. the Account Number) of the AWS Account that contains the Federated Role that will assume the Truster Role that you're creating. The Trust Policy associated to the newly created AWS Chained Role should look as follows. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::111122223333:root\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": {} } ] } In this Trust Policy 111122223333 corresponds to the AWS Federated Account's Account ID , specified in the AWS Chained Role's creation wizard. As you can see, the Principal attribute's value is arn:aws:iam::111122223333:root ; this value makes every IAM entity, inside the 111122223333 account, able to assume the AWS Chained Role. If you want to restrict access to a specific AWS IAM Role/User in the AWS Federated Account, you should specify the AWS IAM Role/User ARN as the Principal attribute's value. 3. Allow Programmatic and AWS Management Console access Select Allow programmatic and AWS Management Console access and click on Next: Permissions button. 4. Add policy Select the policy you want to attach to the newly created Role, e.g. AdministratorAccess . Then, click Next: Tags button. 5. Tags definition Add any tag you want if you need to. Then click Next: Review 6. Name the role Assign a name to the Role and click Create Role . Edit an existing role Go to the IAM console in your AWS Account and select Roles from the left-side column. 1. Select the role you want to edit From the list of Roles, find the Role you want to edit and click on its Role name . A summary of the role will be displayed. 2. Edit trust relationships In the Role\u2019s summary, click on the \u201cTrust relationships\u201d tab. Click on Edit trust relationship , and you're able to modify it. 3. Update Trust Policy Click on \u201cUpdate Trust Policy\u201d to save changes.","title":"Setup Trust Relationship"},{"location":"tutorials/aws/chained/trust_setup/#create-trust-relationship-between-an-aws-federated-role-and-an-aws-chained-role","text":"","title":"Create Trust Relationship between an AWS Federated Role and an AWS Chained Role"},{"location":"tutorials/aws/chained/trust_setup/#create-a-new-chained-role-in-the-aws-truster-account","text":"","title":"Create a new Chained Role in the AWS Truster Account"},{"location":"tutorials/aws/chained/trust_setup/#1-go-to-the-iam-console","text":"Go to the IAM console in your AWS Account and select Roles from the left-side column.","title":"1. Go to the IAM console"},{"location":"tutorials/aws/chained/trust_setup/#2-create-role","text":"Click on Create Role and select Another AWS account as the type of trusted entity; then, specify the Account ID (i.e. the Account Number) of the AWS Account that contains the Federated Role that will assume the Truster Role that you're creating. The Trust Policy associated to the newly created AWS Chained Role should look as follows. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::111122223333:root\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": {} } ] } In this Trust Policy 111122223333 corresponds to the AWS Federated Account's Account ID , specified in the AWS Chained Role's creation wizard. As you can see, the Principal attribute's value is arn:aws:iam::111122223333:root ; this value makes every IAM entity, inside the 111122223333 account, able to assume the AWS Chained Role. If you want to restrict access to a specific AWS IAM Role/User in the AWS Federated Account, you should specify the AWS IAM Role/User ARN as the Principal attribute's value.","title":"2. Create role"},{"location":"tutorials/aws/chained/trust_setup/#3-allow-programmatic-and-aws-management-console-access","text":"Select Allow programmatic and AWS Management Console access and click on Next: Permissions button.","title":"3. Allow Programmatic and AWS Management Console access"},{"location":"tutorials/aws/chained/trust_setup/#4-add-policy","text":"Select the policy you want to attach to the newly created Role, e.g. AdministratorAccess . Then, click Next: Tags button.","title":"4. Add policy"},{"location":"tutorials/aws/chained/trust_setup/#5-tags-definition","text":"Add any tag you want if you need to. Then click Next: Review","title":"5. Tags definition"},{"location":"tutorials/aws/chained/trust_setup/#6-name-the-role","text":"Assign a name to the Role and click Create Role .","title":"6. Name the role"},{"location":"tutorials/aws/chained/trust_setup/#edit-an-existing-role","text":"Go to the IAM console in your AWS Account and select Roles from the left-side column.","title":"Edit an existing role"},{"location":"tutorials/aws/chained/trust_setup/#1-select-the-role-you-want-to-edit","text":"From the list of Roles, find the Role you want to edit and click on its Role name . A summary of the role will be displayed.","title":"1. Select the role you want to edit"},{"location":"tutorials/aws/chained/trust_setup/#2-edit-trust-relationships","text":"In the Role\u2019s summary, click on the \u201cTrust relationships\u201d tab. Click on Edit trust relationship , and you're able to modify it.","title":"2. Edit trust relationships"},{"location":"tutorials/aws/chained/trust_setup/#3-update-trust-policy","text":"Click on \u201cUpdate Trust Policy\u201d to save changes.","title":"3. Update Trust Policy"},{"location":"tutorials/aws/federated/assign_role/","text":"Assign the role to G Suite Principal This tutorial explains how to federate a Role with existing G Suite Users. 1. Access your G Suite admin console Move to the Users section; 2. Select the user Select the user you to want to enable SSO access to AWS and click on User Information 3. Edit AWS SAML Information. In the IAM_Role field, insert the role Role ARN and IDP ARN separated with a comma and without spaces. Insert 28800 (seconds) in the SessionDuration field. You successfully assigned a role to User. Now the user can log in to the federated AWS account using its corporate identity.","title":"Assign Role to GSuite Principal"},{"location":"tutorials/aws/federated/assign_role/#assign-the-role-to-g-suite-principal","text":"This tutorial explains how to federate a Role with existing G Suite Users.","title":"Assign the role to G Suite Principal"},{"location":"tutorials/aws/federated/assign_role/#1-access-your-g-suite-admin-console","text":"Move to the Users section;","title":"1. Access your G Suite admin console"},{"location":"tutorials/aws/federated/assign_role/#2-select-the-user","text":"Select the user you to want to enable SSO access to AWS and click on User Information","title":"2. Select the user"},{"location":"tutorials/aws/federated/assign_role/#3-edit-aws-saml-information","text":"In the IAM_Role field, insert the role Role ARN and IDP ARN separated with a comma and without spaces. Insert 28800 (seconds) in the SessionDuration field. You successfully assigned a role to User. Now the user can log in to the federated AWS account using its corporate identity.","title":"3. Edit AWS SAML Information."},{"location":"tutorials/aws/federated/aws_federation_setup/","text":"How to federate your AWS account with G Suite To enable the federation from both sides you have to create an Identity Provider entity in your AWS account. 1. Log into your AWS Account Open the IAM section, and from the left-side column select Identity Providers. 2. Create a Provider Click on Create Provider , select SAML in the Provider Type dropdown and choose a name for the Provider (eg. \"GSuiteSAML\") and upload the metadata.xml file previously downloaded [link tutorial 1]. 3. Save Your AWS account is successfully federated with G Suite. Now you can start to create, modify, and assign roles to Principals. Follow up to the next tutorial to learn how to create or edit a role to be automatically assumed after Single-Sign-On.","title":"AWS Federation"},{"location":"tutorials/aws/federated/aws_federation_setup/#how-to-federate-your-aws-account-with-g-suite","text":"To enable the federation from both sides you have to create an Identity Provider entity in your AWS account.","title":"How to federate your AWS account with G Suite"},{"location":"tutorials/aws/federated/aws_federation_setup/#1-log-into-your-aws-account","text":"Open the IAM section, and from the left-side column select Identity Providers.","title":"1. Log into your AWS Account"},{"location":"tutorials/aws/federated/aws_federation_setup/#2-create-a-provider","text":"Click on Create Provider , select SAML in the Provider Type dropdown and choose a name for the Provider (eg. \"GSuiteSAML\") and upload the metadata.xml file previously downloaded [link tutorial 1].","title":"2. Create a Provider"},{"location":"tutorials/aws/federated/aws_federation_setup/#3-save","text":"Your AWS account is successfully federated with G Suite. Now you can start to create, modify, and assign roles to Principals. Follow up to the next tutorial to learn how to create or edit a role to be automatically assumed after Single-Sign-On.","title":"3. Save"},{"location":"tutorials/aws/federated/enable_federated_access/","text":"Enable federated access on AWS role After completing this tutorial the federation process is still not over. Go to the next tutorial to complete the procedure and start using SSO. Create a new role 1. Go to the IAM console Go to the IAM console in your AWS Account and select Roles from the left-side column. 2. Create role Click on Create Role and select SAML 2.0 federation as the type of trusted entity; from the SAML provider drop-down menu, select the IAM Identity Provider created in the previous step. 3. Allow Programmatic and AWS Management Console access Select Allow programmatic and AWS Management Console access and click on Next: Permissions * button. 4. Add policy Select the policy you want to attach to the newly created Role, e.g. AdministratorAccess . Then, click Next: Tags button. 5. Tags definition Add any tag you want if you need to. Then click Next: Review 6. Name the role Assign a name to the Role and click Create Role . Edit an existing role Go to the IAM console in your AWS Account and select Roles from the left-side column. 1. Select the role you want to edit From the list of Roles, find the Role you want to edit and click on its Role name . A summary of the role will be displayed. 2. Edit trust relationships In the Role\u2019s summary, click on the \u201c Trust relationships\u201d tab. Click on Edit trust relationship and paste the. 3. Update Trust Policy Click on \u201c Update Trust Policy\u201d to save changes","title":"Enable Federated Access"},{"location":"tutorials/aws/federated/enable_federated_access/#enable-federated-access-on-aws-role","text":"After completing this tutorial the federation process is still not over. Go to the next tutorial to complete the procedure and start using SSO.","title":"Enable federated access on AWS role"},{"location":"tutorials/aws/federated/enable_federated_access/#create-a-new-role","text":"","title":"Create a new role"},{"location":"tutorials/aws/federated/enable_federated_access/#1-go-to-the-iam-console","text":"Go to the IAM console in your AWS Account and select Roles from the left-side column.","title":"1. Go to the IAM console"},{"location":"tutorials/aws/federated/enable_federated_access/#2-create-role","text":"Click on Create Role and select SAML 2.0 federation as the type of trusted entity; from the SAML provider drop-down menu, select the IAM Identity Provider created in the previous step.","title":"2. Create role"},{"location":"tutorials/aws/federated/enable_federated_access/#3-allow-programmatic-and-aws-management-console-access","text":"Select Allow programmatic and AWS Management Console access and click on Next: Permissions * button.","title":"3. Allow Programmatic and AWS Management Console access"},{"location":"tutorials/aws/federated/enable_federated_access/#4-add-policy","text":"Select the policy you want to attach to the newly created Role, e.g. AdministratorAccess . Then, click Next: Tags button.","title":"4. Add policy"},{"location":"tutorials/aws/federated/enable_federated_access/#5-tags-definition","text":"Add any tag you want if you need to. Then click Next: Review","title":"5. Tags definition"},{"location":"tutorials/aws/federated/enable_federated_access/#6-name-the-role","text":"Assign a name to the Role and click Create Role .","title":"6. Name the role"},{"location":"tutorials/aws/federated/enable_federated_access/#edit-an-existing-role","text":"Go to the IAM console in your AWS Account and select Roles from the left-side column.","title":"Edit an existing role"},{"location":"tutorials/aws/federated/enable_federated_access/#1-select-the-role-you-want-to-edit","text":"From the list of Roles, find the Role you want to edit and click on its Role name . A summary of the role will be displayed.","title":"1. Select the role you want to edit"},{"location":"tutorials/aws/federated/enable_federated_access/#2-edit-trust-relationships","text":"In the Role\u2019s summary, click on the \u201c Trust relationships\u201d tab. Click on Edit trust relationship and paste the.","title":"2. Edit trust relationships"},{"location":"tutorials/aws/federated/enable_federated_access/#3-update-trust-policy","text":"Click on \u201c Update Trust Policy\u201d to save changes","title":"3. Update Trust Policy"},{"location":"tutorials/aws/federated/gsuite_federation_setup/","text":"How to set up G Suite federation Let\u2019s start with G Suite & AWS federation: 1. Log in to your Google Admin Console and click on the user button as shown in figure: 2. Create a new category of custom attributes a. Click Manage Custom Attributes In the G Suite directory, once in Users screen, select More from the top menu. Then select \u201c Manage Custom Attributes\u201d. b. Choose \u201cAdd Custom Attribute\u201d In the top-right corner of the page click on \u201cAdd Custom Attribute\u201d. c. Fill the Form Fill the form like in the figure below: 3. Create a SAML-Based application In order to set up a SAML-Based Single Sign-On, we first need to create a custom application representing AWS. a. Return to main page and browse to the \"Apps\" section b. Add a new SAML application Select Amazon Web Services template Click on the \u201cAdd apps\u201d selector in the menu bar, then \"Search app\" like in figure: Then Search for \"Amazon Web Services\", wait for search to complete then select the one in figure, being careful to check that is a \"Web SAML\": Save the IDP Metadata file The IDP Metadata is a .xml file containing configuration parameters and the X509 certificate. It enables the trust relationship between Identity and Service Provider. Save it; we will use it in a later step. The metadata file must be kept secret and securely stored : the security of the solution relies on its secrecy. Choose the Service Provider\u2019s details id Under Service Provider Details , select EMAIL choosing from the Name ID Format drop-down like in figure, leave the rest as it is. Add the attribute Mapping The attributes previously created are associated and mapped to the SAML assertion . The first 2 are predefined by Google, set the following mapping with the help of the figure: https://aws.amazon.com/SAML/Attributes/RoleSessionName -> Basic Information -> Primary Email https://aws.amazon.com/SAML/Attributes/Role -> AWS_SAML -> IAM_Role Add another mapping and set it like this: - https://aws.amazon.com/SAML/Attributes/SessionDuration -> AWS_SAML -> SessionDuration This is the final setup: 4. Enable the SAML App a. Turn ON the App Go back to the **SAML app menu list (from the Admin Panel, select \u201cApps\u201d) and select the Amazon Web Services line: Go to the user panel like in the figure and click on the down chevron icon: Once in the panel click on \"ON for everyone\" and press save. Now you\u2019ve added the Amazon Web Service application to your App Google menu. b. Get the SAML App link Click on your App Google menu, locate the new entry, and right-click on it to copy its value. We will need this in the next tutorial. Congratulations, the first phase of the federation is complete, follow up with the next tutorial to set up the federation on AWS side.","title":"G Suite Federation"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#how-to-set-up-g-suite-federation","text":"Let\u2019s start with G Suite & AWS federation:","title":"How to set up G Suite federation"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#1-log-in-to-your-google-admin-console-and-click-on-the-user-button-as-shown-in-figure","text":"","title":"1. Log in to your Google Admin Console and click on the user button as shown in figure:"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#2-create-a-new-category-of-custom-attributes","text":"","title":"2. Create a new category of custom attributes"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#a-click-manage-custom-attributes","text":"In the G Suite directory, once in Users screen, select More from the top menu. Then select \u201c Manage Custom Attributes\u201d.","title":"a. Click Manage Custom Attributes"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#b-choose-add-custom-attribute","text":"In the top-right corner of the page click on \u201cAdd Custom Attribute\u201d.","title":"b. Choose \u201cAdd Custom Attribute\u201d"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#c-fill-the-form","text":"Fill the form like in the figure below:","title":"c. Fill the Form"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#3-create-a-saml-based-application","text":"In order to set up a SAML-Based Single Sign-On, we first need to create a custom application representing AWS.","title":"3. Create a SAML-Based application"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#a-return-to-main-page-and-browse-to-the-apps-section","text":"","title":"a. Return to main page and browse to the \"Apps\" section"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#b-add-a-new-saml-application","text":"","title":"b. Add a new SAML application"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#select-amazon-web-services-template","text":"Click on the \u201cAdd apps\u201d selector in the menu bar, then \"Search app\" like in figure: Then Search for \"Amazon Web Services\", wait for search to complete then select the one in figure, being careful to check that is a \"Web SAML\":","title":"Select Amazon Web Services template"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#save-the-idp-metadata-file","text":"The IDP Metadata is a .xml file containing configuration parameters and the X509 certificate. It enables the trust relationship between Identity and Service Provider. Save it; we will use it in a later step. The metadata file must be kept secret and securely stored : the security of the solution relies on its secrecy.","title":"Save the IDP Metadata file"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#choose-the-service-providers-details-id","text":"Under Service Provider Details , select EMAIL choosing from the Name ID Format drop-down like in figure, leave the rest as it is.","title":"Choose the Service Provider\u2019s details id"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#add-the-attribute-mapping","text":"The attributes previously created are associated and mapped to the SAML assertion . The first 2 are predefined by Google, set the following mapping with the help of the figure: https://aws.amazon.com/SAML/Attributes/RoleSessionName -> Basic Information -> Primary Email https://aws.amazon.com/SAML/Attributes/Role -> AWS_SAML -> IAM_Role Add another mapping and set it like this: - https://aws.amazon.com/SAML/Attributes/SessionDuration -> AWS_SAML -> SessionDuration This is the final setup:","title":"Add the attribute Mapping"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#4-enable-the-saml-app","text":"","title":"4. Enable the SAML App"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#a-turn-on-the-app","text":"Go back to the **SAML app menu list (from the Admin Panel, select \u201cApps\u201d) and select the Amazon Web Services line: Go to the user panel like in the figure and click on the down chevron icon: Once in the panel click on \"ON for everyone\" and press save. Now you\u2019ve added the Amazon Web Service application to your App Google menu.","title":"a. Turn ON the App"},{"location":"tutorials/aws/federated/gsuite_federation_setup/#b-get-the-saml-app-link","text":"Click on your App Google menu, locate the new entry, and right-click on it to copy its value. We will need this in the next tutorial. Congratulations, the first phase of the federation is complete, follow up with the next tutorial to set up the federation on AWS side.","title":"b. Get the SAML App link"},{"location":"tutorials/aws/federated/leapp_federated_setup/","text":"How to create a Federated Role Access Method for AWS with Leapp If this is your first time accessing Leapp please follow this guide: First setup . 1) From your quick list click on the \"+\" button located on the top-right corner of the app You'll be presented with the Provider Selection screen: 2) Choose \" AWS \" as a Cloud Provider, than you'll be presented with the Access Strategy selection screen: Select \" IAM Federated Role \" as the Access Method. 3) As the last screen you'll be presented with the actual account creation screen: AWS Profile : here you can select (ora add by writing and pressing ENTER) a named profile to use for this credential set, base one is \"default\" Session Alias: choose a unique name suitable to recognize the Access Method. Role ARN : Grab the Role ARN from your AWS account (Go to IAM service \u2192 Roles, and check for the federated role ). Region : select the region you want to start your session in. SAML 2.0 Url : here you can select (ora add by writing and pressing ENTER) a SAML 2.0 URL to use with your Federated Account. IdpARN : Is the Idp ARN you can recover by going into your AWS Account \u2192 IAM service \u2192 Identity Providers \u2192 Select your GSUITE federation \u2192 copy the ARN value. Finally press Save .","title":"Setup Leapp Federated"},{"location":"tutorials/aws/federated/leapp_federated_setup/#how-to-create-a-federated-role-access-method-for-aws-with-leapp","text":"If this is your first time accessing Leapp please follow this guide: First setup .","title":"How to create a Federated Role Access Method for AWS with Leapp"},{"location":"tutorials/aws/federated/leapp_federated_setup/#1-from-your-quick-list-click-on-the-button-located-on-the-top-right-corner-of-the-app","text":"You'll be presented with the Provider Selection screen:","title":"1) From your quick list click on the \"+\" button located on the top-right corner of the app"},{"location":"tutorials/aws/federated/leapp_federated_setup/#2-choose-aws-as-a-cloud-provider-than-youll-be-presented-with-the-access-strategy-selection-screen","text":"Select \" IAM Federated Role \" as the Access Method.","title":"2) Choose \"AWS\" as a Cloud Provider, than you'll be presented with the Access Strategy selection screen:"},{"location":"tutorials/aws/federated/leapp_federated_setup/#3-as-the-last-screen-youll-be-presented-with-the-actual-account-creation-screen","text":"AWS Profile : here you can select (ora add by writing and pressing ENTER) a named profile to use for this credential set, base one is \"default\" Session Alias: choose a unique name suitable to recognize the Access Method. Role ARN : Grab the Role ARN from your AWS account (Go to IAM service \u2192 Roles, and check for the federated role ). Region : select the region you want to start your session in. SAML 2.0 Url : here you can select (ora add by writing and pressing ENTER) a SAML 2.0 URL to use with your Federated Account. IdpARN : Is the Idp ARN you can recover by going into your AWS Account \u2192 IAM service \u2192 Identity Providers \u2192 Select your GSUITE federation \u2192 copy the ARN value. Finally press Save .","title":"3) As the last screen you'll be presented with the actual account creation screen:"},{"location":"tutorials/azure/gsuite_federation_setup/","text":"Federation between G Suite and Azure AD G Suite side G Suite SAML Application setup. Modal from which you can download the metadata XML file. Azure side Custom domain name Create a custom domain name. Verify through DNS TXT record. Leave .onmicrosoft.com as the primary domain Inside the Azure Active Directory Service, go to Custom domain names. Here you can find default and custom domain names associated to the root account. A custom domain name could be federated to G Suite only if it is not the primary account. Create Users You need to create a User in Azure Active Directory for each G Suite User to whom you want to allow access to your Tenant's resources. Users' permissions should be set inside the Subscription's \"Access control (IAM)\" section. For example, create jon@your_domain.net and doe@your_domain.net. We specified your_domain.net for the sake of this tutorial. Set Users' ImmutableId ImmutableId must be set before federating G Suite with Azure Active Directory. Set-MsolUser -UserPrincipalName jon@your_domain.net -ImmutableId jon@your_domain.net Set-MsolUser -UserPrincipalName doe@your_domain.net -ImmutableId doe@your_domain.net Remove users from recycle bin to avoid conflicts when setting new users' ImmutableId. Federation between G Suite and Azure AD through PowerShell script Prerequisites Create new custom domain; it should NOT be the primary one Set users' ImmutableId Run MSOnline module's Set-MsolDomainAuthentication as a Member and not as a Guest user Member user should have sufficient privileges to run MSOnline module's Connect-MsolService You can find the MSOnline module's documentation here . USE POWERSHELL AT ALL COSTS!!! Federation could not be done via Azure Portal. Therefore we rely on PowerShell run with Administrator privileges. Install-Module MSOnline Connect-MsolService $domainName = \"your_domain.net\" [xml]$idp = Get-Content <metadata-xml-file-path> $activeLogonUri = \"https://login.microsoftonline.com/login.srf\" $signingCertificate = ($idp.EntityDescriptor.IDPSSODescriptor.KeyDescriptor.KeyInfo.X509Data.X509Certificate | Out-String).Trim() $issuerUri = $idp.EntityDescriptor.entityID $logOffUri = $idp.EntityDescriptor.IDPSSODescriptor.SingleSignOnService.Location[0] $passiveLogOnUri = $idp.EntityDescriptor.IDPSSODescriptor.SingleSignOnService.Location[0] Set-MsolDomainAuthentication ` -DomainName $domainName ` -FederationBrandName $domainName ` -Authentication Federated ` -PassiveLogOnUri $passiveLogOnUri ` -ActiveLogOnUri $activeLogonUri ` -SigningCertificate $signingCertificate ` -IssuerUri $issuerUri ` -LogOffUri $logOffUri ` -PreferredAuthenticationProtocol \"SAMLP\" <metadata-xml-file-path> : path to the XML file downloaded from the G Suite SAML App.","title":"G Suite Federation"},{"location":"tutorials/azure/gsuite_federation_setup/#federation-between-g-suite-and-azure-ad","text":"","title":"Federation between G Suite and Azure AD"},{"location":"tutorials/azure/gsuite_federation_setup/#g-suite-side","text":"G Suite SAML Application setup. Modal from which you can download the metadata XML file.","title":"G Suite side"},{"location":"tutorials/azure/gsuite_federation_setup/#azure-side","text":"","title":"Azure side"},{"location":"tutorials/azure/gsuite_federation_setup/#custom-domain-name","text":"Create a custom domain name. Verify through DNS TXT record. Leave .onmicrosoft.com as the primary domain Inside the Azure Active Directory Service, go to Custom domain names. Here you can find default and custom domain names associated to the root account. A custom domain name could be federated to G Suite only if it is not the primary account.","title":"Custom domain name"},{"location":"tutorials/azure/gsuite_federation_setup/#create-users","text":"You need to create a User in Azure Active Directory for each G Suite User to whom you want to allow access to your Tenant's resources. Users' permissions should be set inside the Subscription's \"Access control (IAM)\" section. For example, create jon@your_domain.net and doe@your_domain.net. We specified your_domain.net for the sake of this tutorial.","title":"Create  Users"},{"location":"tutorials/azure/gsuite_federation_setup/#set-users-immutableid","text":"ImmutableId must be set before federating G Suite with Azure Active Directory. Set-MsolUser -UserPrincipalName jon@your_domain.net -ImmutableId jon@your_domain.net Set-MsolUser -UserPrincipalName doe@your_domain.net -ImmutableId doe@your_domain.net Remove users from recycle bin to avoid conflicts when setting new users' ImmutableId.","title":"Set Users' ImmutableId"},{"location":"tutorials/azure/gsuite_federation_setup/#federation-between-g-suite-and-azure-ad-through-powershell-script","text":"Prerequisites Create new custom domain; it should NOT be the primary one Set users' ImmutableId Run MSOnline module's Set-MsolDomainAuthentication as a Member and not as a Guest user Member user should have sufficient privileges to run MSOnline module's Connect-MsolService You can find the MSOnline module's documentation here . USE POWERSHELL AT ALL COSTS!!! Federation could not be done via Azure Portal. Therefore we rely on PowerShell run with Administrator privileges. Install-Module MSOnline Connect-MsolService $domainName = \"your_domain.net\" [xml]$idp = Get-Content <metadata-xml-file-path> $activeLogonUri = \"https://login.microsoftonline.com/login.srf\" $signingCertificate = ($idp.EntityDescriptor.IDPSSODescriptor.KeyDescriptor.KeyInfo.X509Data.X509Certificate | Out-String).Trim() $issuerUri = $idp.EntityDescriptor.entityID $logOffUri = $idp.EntityDescriptor.IDPSSODescriptor.SingleSignOnService.Location[0] $passiveLogOnUri = $idp.EntityDescriptor.IDPSSODescriptor.SingleSignOnService.Location[0] Set-MsolDomainAuthentication ` -DomainName $domainName ` -FederationBrandName $domainName ` -Authentication Federated ` -PassiveLogOnUri $passiveLogOnUri ` -ActiveLogOnUri $activeLogonUri ` -SigningCertificate $signingCertificate ` -IssuerUri $issuerUri ` -LogOffUri $logOffUri ` -PreferredAuthenticationProtocol \"SAMLP\" <metadata-xml-file-path> : path to the XML file downloaded from the G Suite SAML App.","title":"Federation between G Suite and Azure AD through PowerShell script"},{"location":"tutorials/azure/leapp_federated_setup/","text":"If this is your first time accessing Leapp please follow this guide: First setup . 1) From your quick list click on the \"+\" button located on the top-right corner of the app You'll be presented with the Provider Selection screen: 2) Choose \" Azure \" as a Cloud Provider, then you'll be ported directly to the creation form: 3) As the last screen you'll be presented with the actual account creation screen: Account Alias: choose a unique name suitable to recognize the Access Strategy. Subscription Id: get the subscription Id from Azure Active Directory in the Azure console Tenant Id : get the tenant Id from Azure Directory in the Azure console Location : the default location to use for this credential set, this value overrides the one in the option panel Finally press Save .","title":"Setup Leapp Federated"},{"location":"tutorials/misc/defaults/","text":"Changing a Default Region or Location means that every new Strategy , both AWS or AZURE, will present the selected Region (AWS) or Location (AZURE) as the one defined by default in the select option of the form . Also, a default Region/Location will be used to patch old sessions prior to release 0.4.3, to have it as the default one . Every Service Provider call done with the active session will be directed (if possible) in the selected region . The user has also the ability to switch any session's Region/Location anytime after session's creation. To do so check this other guide . Where to change default Region/Location Just go to the option page, you'll find the new selectors there, as show in figure:","title":"Default Region/Location"},{"location":"tutorials/misc/defaults/#where-to-change-default-regionlocation","text":"Just go to the option page, you'll find the new selectors there, as show in figure:","title":"Where to change default Region/Location"},{"location":"tutorials/misc/named_profiles/","text":"Named Profiles are a way AWS uses to maintain more than one set of credentials active for you to use with AWS-CLI, SDK, or other third-party tools. Named profiles are stored in ~/.aws/credentials file in the ini file format . Named Profiles have a default one which is the one you get from aws configure command. Leapp can, from release 0.4.7 , manage more than one profile, to allow users to have multiple credentials set at the same time. Named Profiles are selectable directly when creating an AWS session ( Federated , Truster , Plain ), by using the selector provided in the form. It is also possible to create a new named profile directly from the selector by typing a new name and by pressing ENTER key . The new name is directly added to the named profile list and it will be possible to use it for other sessions too. AWS SSO sessions will have default as named profile when obtained through Login or Sync, to change the named profile associated to a session you have to use the \"Change Profile\" option in the session list. Named Profile List Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile. Session Options A named profile can also be changed directly from an AWS session element in the main list . There you can add or select a new named profile the same way you would from the add session form . Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"Named Profiles"},{"location":"tutorials/misc/named_profiles/#named-profile-list","text":"Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile.","title":"Named Profile List"},{"location":"tutorials/misc/named_profiles/#session-options","text":"A named profile can also be changed directly from an AWS session element in the main list . There you can add or select a new named profile the same way you would from the add session form . Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"Session Options"},{"location":"tutorials/misc/quick_list/","text":"Manage Quick List The Quick List represents a fast way to generate temporary credentials associated to a Session, which is defined by the following couples: - Account/Role - Access/Secret key - Subscription Id/Tenant Id Account and Roles could be either for Federated IAM Role or Chained IAM Role . Access and Secret keys are for IAM User access. Finally Subscription and Tenant Id are for Azure sessions. If you want to add a new Session to the Quick List, you have to follow our other tutorials: How to create a IAM Federated Role Access Method on Leapp How to create a IAM Chained Role Access Method on Leapp How to create a IAM User Access Method on Leapp How to create an Azure Access Method on Leapp","title":"Quick List"},{"location":"tutorials/misc/quick_list/#manage-quick-list","text":"The Quick List represents a fast way to generate temporary credentials associated to a Session, which is defined by the following couples: - Account/Role - Access/Secret key - Subscription Id/Tenant Id Account and Roles could be either for Federated IAM Role or Chained IAM Role . Access and Secret keys are for IAM User access. Finally Subscription and Tenant Id are for Azure sessions. If you want to add a new Session to the Quick List, you have to follow our other tutorials: How to create a IAM Federated Role Access Method on Leapp How to create a IAM Chained Role Access Method on Leapp How to create a IAM User Access Method on Leapp How to create an Azure Access Method on Leapp","title":"Manage Quick List"},{"location":"tutorials/misc/session_region/","text":"Both for active and inactive sessions you can access the change region modal by clicking on a session's menu button: And by selecting \"Change Region/Location\" (depending on the type of Session). Here you'll get into a modal to change the current region for a session. Note: if the session is active, the actual credentials will be rotated by new ones that reflect the newly selected region .","title":"Session Region/Location"},{"location":"use-cases/aws_iam_role/","text":"AWS IAM Roles AWS IAM Federated Role Federation is established between G Suite , Okta , OneLogin and AWS . No more AWS credentials management is needed. Leapp allows you to get to cloud resources with company email and password. See setup tutorial AWS IAM Chained Role Access to an Aws Account Role via another AWS Account role or an IAM user, thanks to a cross-account role available via STS . In this access strategy a Truster Role or a Plain User is assumed by a federated role . See setup tutorial Note: it's possible to apply MFA to a truster session by setting it on the plain account it relies on. Please see MFA section for more details.","title":"AWS IAM Role"},{"location":"use-cases/aws_iam_role/#aws-iam-roles","text":"","title":"AWS IAM Roles"},{"location":"use-cases/aws_iam_role/#aws-iam-federated-role","text":"Federation is established between G Suite , Okta , OneLogin and AWS . No more AWS credentials management is needed. Leapp allows you to get to cloud resources with company email and password. See setup tutorial","title":"AWS IAM Federated Role"},{"location":"use-cases/aws_iam_role/#aws-iam-chained-role","text":"Access to an Aws Account Role via another AWS Account role or an IAM user, thanks to a cross-account role available via STS . In this access strategy a Truster Role or a Plain User is assumed by a federated role . See setup tutorial Note: it's possible to apply MFA to a truster session by setting it on the plain account it relies on. Please see MFA section for more details.","title":"AWS IAM Chained Role"},{"location":"use-cases/aws_iam_user/","text":"AWS IAM User Leapp automatically uses your Access Key ID and Secret Access Key for generating temporary credentials through the AWS STS Get Session Token . Access and secret keys are safely stored in the system vault. Please head to vault strategy section if you want to know how Leapp manages your secrets. See setup tutorial Note: it's possible to assign an MFA device to a plain session. Please see MFA section for more details. Caveats Generating credentials from AWS STS Get Session Token results in some limits to the actions that the resulting temporary credentials can perform. Cannot call IAM API operations unless MFA information is included with the request. Cannot call AWS STS API operations except AssumeRole or GetCallerIdentity. SSO to console is not allowed.","title":"AWS IAM User"},{"location":"use-cases/aws_iam_user/#aws-iam-user","text":"Leapp automatically uses your Access Key ID and Secret Access Key for generating temporary credentials through the AWS STS Get Session Token . Access and secret keys are safely stored in the system vault. Please head to vault strategy section if you want to know how Leapp manages your secrets. See setup tutorial Note: it's possible to assign an MFA device to a plain session. Please see MFA section for more details.","title":"AWS IAM User"},{"location":"use-cases/aws_iam_user/#caveats","text":"Generating credentials from AWS STS Get Session Token results in some limits to the actions that the resulting temporary credentials can perform. Cannot call IAM API operations unless MFA information is included with the request. Cannot call AWS STS API operations except AssumeRole or GetCallerIdentity. SSO to console is not allowed.","title":"Caveats"},{"location":"use-cases/aws_sso/","text":"AWS Single Sign-On Access to your AWS Accounts through Leapp and let the App manage all the available session to generate Temporary Access and Secret keys. See setup tutorial","title":"AWS SSO"},{"location":"use-cases/aws_sso/#aws-single-sign-on","text":"Access to your AWS Accounts through Leapp and let the App manage all the available session to generate Temporary Access and Secret keys. See setup tutorial","title":"AWS Single Sign-On"},{"location":"use-cases/azure/","text":"Azure Access Method Use Leapp to do Single Sign On with G Suite on Azure to get access to your Subscriptions . In this use case is mandatory to have defined a Federation between Google and Azure. Leapp manage the login process for you to have Azure CLI ready to be used. See setup tutorial","title":"Azure"},{"location":"use-cases/azure/#azure-access-method","text":"Use Leapp to do Single Sign On with G Suite on Azure to get access to your Subscriptions . In this use case is mandatory to have defined a Federation between Google and Azure. Leapp manage the login process for you to have Azure CLI ready to be used. See setup tutorial","title":"Azure Access Method"}]}